from net.tcp.server import Client
from os import tar
from os import OsError
from os.path import Path
from os.subprocess import run
from toml import decode as toml_decode
from toml import Value as TomlValue
from json import decode as json_decode
from graphql import parse as graphql_parse
from io.buffered_reader import BufferedReader
from fiber import Fiber
from fiber import Event
from http.header_parser import parse_request
from http import HttpError
from http.header_parser import Request
from semver import Version
from string import StringBuilder
from . import create_token
from . import Status
from .database import Database
from .database import Release
from .graphql import GraphQL
from .statistics import Statistics
from .activities import Activities

RE_MYS_VERSION_STANDARD_LIBRARY: regex = (
    re"^/\d+\.\d+\.\d+[\w-]*/standard-library.html")
RE_MYS_VERSION_ACTIVITY: regex = re"^/\d+\.\d+\.\d+[\w-]*/activity.html"
RE_MYS_VERSION_STATISTICS: regex = re"^/\d+\.\d+\.\d+[\w-]*/statistics.html"
RE_MYS_VERSION_WORLD_SVG: regex = re"^/\d+\.\d+\.\d+[\w-]*/_images/world.svg"
RE_MYS_VERSION: regex = re"^/\d+\.\d+\.\d+[\w-]*/"
RE_PACKAGE_TAR_GZ: regex = re"^/package/([\w-]+)-\d+\.\d+\.\d+[\w-]*.tar.gz$"
RE_PACKAGE_LATEST_TAR_GZ: regex = re"^/package/([\w-]+)-latest.tar.gz$"
RE_PACKAGE_OPERATIONS: regex = re"^/package/[\w-]+$"
RE_PACKAGE_LATEST: regex = re"^/package/[\w-]+/latest/"
RE_MYS_TAR_GZ: regex = re"^/mys-\d+\.\d+\.\d+[\w-]*.tar.gz$"
RE_PACKAGE_NAME: regex = re"^[\w\-]+$"
RE_STANDARD_LIBRARY_BUILD_LOG: regex = re"^/standard-library/([\w-]+)/build-log.html$"
RE_STANDARD_LIBRARY_COVERAGE_TAR_GZ: regex = re"^/standard-library/([\w-]+)/coverage.tar.gz$"
RE_STANDARD_LIBRARY_COVERAGE: regex = re"^/standard-library/([\w-]+)/coverage/"
RE_STANDARD_LIBRARY_BUILD_RESULT: regex = re"^/standard-library/([\w-]+)/build-result.txt$"
RE_STANDARD_LIBRARY_DEPENDENTS: regex = re"^/standard-library/([\w-]+)/dependents.txt$"

FILE_SUFFIX_TO_CONTENT_TYPE: {string: string} = {
    ".html": "text/html",
    ".css": "text/css",
    ".js": "application/javascript",
    ".svg": "image/svg+xml",
    ".png": "image/png",
    ".woff2": "font/woff2",
    ".json": "application/json",
}

HEADERS_END: bytes = b"\r\n\r\n"

STATUS_STRINGS: {i64: string} = {
    i64(Status.Continue): "Continue",
    i64(Status.Ok): "OK",
    i64(Status.Found): "Found",
    i64(Status.BadRequest): "Bad Request",
    i64(Status.Unauthorized): "Unauthorized",
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

func builds_to_emoji(result: string) -> string:
    match result:
        case "yes":
            return "✅"
        case "no":
            return "❌"
        case _:
            return "🤔"

func make_package_link(message: string) -> string:
    parts = message.split(" ")
    name = parts[1]
    parts[1] = f"<a href=\"/package/{name}/latest/index.html\">{name}</a>"

    return " ".join(parts)

func create_request_table(name: string, requests: {string: i64}) -> (string, i64):
    total_number_of_requests = 0
    row_index = 0
    builder = StringBuilder()
    builder += (
        "<table class=\"docutils align-default\" "
        f"id=\"{name}\">\n"
        "  <thead>\n"
        "    <tr class=\"row-odd\">\n"
        f"      <th class=\"head\" onclick=\"sortTable(0, '{name}')\">"
        "Path</th>\n"
        f"      <th class=\"head\" onclick=\"sortTable(1, '{name}')\">"
        "Count</th>\n"
        "    </tr>\n"
        "  </thead>\n"
        "  <tbody>\n"
    )

    for path, count in requests:
        total_number_of_requests += count

        if (row_index % 2) == 0:
            builder += "    <tr class=\"row-even\">\n"
        else:
            builder += "    <tr class=\"row-odd\">\n"

        builder += f"      <td>{path}</td>\n"
        builder += f"      <td>{count}</td>\n"
        builder += "    </tr>\n"
        row_index += 1

    builder += (
        "  </tbody>\n"
        "</table>\n"
    )

    return builder.to_string(), total_number_of_requests

SORT_TABLE_JS: string = """\
<script>
function sortTable(n, element) {
  var table, rows, switching, i, x, y;
  var shouldSwitch, dir, switchcount = 0;
  table = document.getElementById(element);
  switching = true;
  dir = \"asc\";
  while (switching) {
    switching = false;
    rows = table.rows;
    for (i = 1; i < (rows.length - 1); i++) {
      shouldSwitch = false;
      x = rows[i].getElementsByTagName(\"TD\")[n].innerHTML;
      y = rows[i + 1].getElementsByTagName(\"TD\")[n].innerHTML;
      if (dir == \"asc\") {
        if (((n < 1) && (x > y))
            || ((n == 1) && (parseInt(x) > parseInt(y)))) {
          shouldSwitch = true;
          break;
        }
      } else if (dir == \"desc\") {
        if (((n < 1) && (x < y))
            || ((n == 1) && (parseInt(x) < parseInt(y)))) {
          shouldSwitch = true;
          break;
        }
      }
    }
    if (shouldSwitch) {
      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
      switching = true;
      switchcount++;
    } else {
      if (switchcount == 0 && dir == \"asc\") {
        dir = \"desc\";
        switching = true;
      }
    }
  }
}
</script>
"""

class ClientHandlerFiber(Fiber):
    database: Database
    statistics: Statistics
    event: Event
    client: Client
    idle_client_handlers: [i64]
    idle_client_handlers_ready: Event
    index: i64
    root_directory: Path
    response_status: Status
    _buffered_reader: BufferedReader
    _graphql: GraphQL
    _activities: Activities

    func __init__(self,
                  database: Database,
                  statistics: Statistics,
                  graphql: GraphQL,
                  activities: Activities,
                  idle_client_handlers: [i64],
                  idle_client_handlers_ready: Event,
                  index: i64):
        self.database = database
        self.statistics = statistics
        self.idle_client_handlers = idle_client_handlers
        self.idle_client_handlers_ready = idle_client_handlers_ready
        self.index = index
        self.root_directory = Path(f".website/{index}")
        self.event = Event()
        self.client = None
        self.create_root_directory()
        self.response_status = Status.Unknown
        self._buffered_reader = None
        self._graphql = graphql
        self._activities = activities

    func create_root_directory(self):
        self.root_directory.rm(recursive=True, force=True)
        self.root_directory.mkdir(exists_ok=True)

    func serve_client(self, client: Client):
        self.client = client
        self._buffered_reader = BufferedReader(client, 1024)
        self.event.set()

    func run(self):
        while True:
            self.event.wait()
            self.event.clear()

            try:
                self.serve()
            except Error as e:
                print(e)

            self.client.disconnect()
            self.idle_client_handlers.append(self.index)
            self.idle_client_handlers_ready.set()

    func make_path(self, path: string) -> Path:
        """Prepend the database root directory path to given path. Given path
        must not start with a slash.

        """

        return self.root_directory.join(path)

    func read_header(self) -> bytes:
        return self._buffered_reader.read_until(HEADERS_END)

    func handle_request(self, request: Request):
        self.response_status = Status.Unknown

        if request.path == "/":
            request.path = "/index.html"

        path = request.path

        if path.match(RE_MYS_VERSION_STANDARD_LIBRARY) is not None:
            self.handle_mys_version_standard_library(request)
            return

        if path.match(RE_MYS_VERSION_ACTIVITY) is not None:
            self.handle_mys_version_activity(request)
            return

        if path.match(RE_MYS_VERSION_STATISTICS) is not None:
            self.handle_mys_version_statistics(request)
            return

        if path.match(RE_MYS_VERSION_WORLD_SVG) is not None:
            self.handle_mys_version_world_svg(request)
            return

        if path.match(RE_MYS_VERSION) is not None:
            self.handle_mys_version(request)
            return

        mo = path.match(RE_PACKAGE_TAR_GZ)

        if mo is not None:
            self.handle_package_tar_gz(request, mo.group(1))
            return

        mo = path.match(RE_PACKAGE_LATEST_TAR_GZ)

        if mo is not None:
            self.handle_package_latest_tar_gz(request, mo.group(1))
            return

        if path.match(RE_PACKAGE_OPERATIONS) is not None:
            self.handle_package_operations(request)
            return

        if path.match(RE_PACKAGE_LATEST) is not None:
            self.handle_package_latest(request)
            return

        if path.starts_with("/package/"):
            self.handle_package(request)
            return

        if path.match(RE_MYS_TAR_GZ) is not None:
            self.handle_mys_tar_gz(request)
            return

        if path == "/favicon.ico":
            self.handle_static_file(request)
            return

        if path == "/standard-library.html":
            self.handle_mys_standard_library(request)
            return

        if path == "/activity.html":
            self.handle_mys_activity(request)
            return

        if path == "/statistics.html":
            self.handle_mys_statistics(request)
            return

        if path == "/_images/world.svg":
            self.handle_mys_world_svg(request)
            return

        mo = path.match(RE_STANDARD_LIBRARY_BUILD_RESULT)

        if mo is not None:
            self.handle_standard_library_build_result(request, mo.group(1))
            return

        mo = path.match(RE_STANDARD_LIBRARY_BUILD_LOG)

        if mo is not None:
            self.handle_standard_library_build_log(request, mo.group(1))
            return

        mo = path.match(RE_STANDARD_LIBRARY_COVERAGE_TAR_GZ)

        if mo is not None:
            self.handle_standard_library_coverage_tar_gz(request, mo.group(1))
            return

        if path.match(RE_STANDARD_LIBRARY_COVERAGE) is not None:
            self.handle_standard_library_coverage(request)
            return

        mo = path.match(RE_STANDARD_LIBRARY_DEPENDENTS)

        if mo is not None:
            self.handle_standard_library_dependents(request, mo.group(1))
            return

        if path == "/standard-library/list.txt":
            self.handle_standard_library_list(request)
            return

        if path == "/graphql":
            self.handle_graphql(request)
            return

        self.handle_mys(request)

    func serve(self):
        header = self.read_header()

        if header is None:
            return

        try:
            request = parse_request(header, len(header))
        except HttpError:
            self.write_response(Status.BadRequest)
            return

        # The handler method may change the path, but we want the
        # original path in the statistics.
        path = request.path

        try:
            self.handle_request(request)
        finally:
            request.path = path
            self.statistics.handle_request(request, self.response_status)

    func handle_mys_version_standard_library(self, request: Request):
        match request.method:
            case "GET":
                path = self.database.make_path(request.path)

                if path.exists():
                    self.write_static_response_ok(path)
                    row_index = 0
                    packages = StringBuilder()
                    packages += (
                        "<table class=\"docutils align-default\">\n"
                        "  <thead>\n"
                        "    <tr class=\"row-odd\">\n"
                        "      <th class=\"head\">Name</th>\n"
                        "      <th class=\"head\">Description</th>\n"
                        "      <th class=\"head\">Version</th>\n"
                        "      <th class=\"head\">Downloads</th>\n"
                        "      <th class=\"head\">Status</th>\n"
                        "    </tr>\n"
                        "  </thead>\n"
                        "  <tbody>\n"
                    )
                    number_of_packages = 0
                    number_of_downloads = 0

                    for package_name in self.database.get_packages():
                        package = self.database.get_package(package_name)
                        number_of_packages += 1
                        number_of_downloads += package.number_of_downloads
                        builds_emoji = builds_to_emoji(package.builds)
                        builds_log_path = (
                            f"/standard-library/{package_name}/build-log.html")
                        coverage_path = (
                            f"/standard-library/{package_name}/coverage/html/index.html")
                        database_doc_path = (
                            f"/package/{package_name}/latest/index.html")

                        if (row_index % 2) == 0:
                            packages += "    <tr class=\"row-even\">\n"
                        else:
                            packages += "    <tr class=\"row-odd\">\n"

                        packages += (
                            f"      <td><a href=\"{database_doc_path}\">"
                            f"{package_name}</a></td>\n")
                        packages += (
                            f"      <td>{package.latest_release.description}</td>\n")
                        packages += f"      <td>{package.latest_release.version}</td>\n"
                        packages += f"      <td>{package.number_of_downloads}</td>\n"
                        packages += "      <td>"
                        packages += (
                            f"<a href=\"{builds_log_path}\">{builds_emoji}</a>")

                        if (package.builds == "yes"
                            and self.database.make_path(coverage_path).exists()):
                            packages += (
                                f" <a href=\"{coverage_path}\">📄</a>")

                        packages += "</td>\n"
                        packages += "    </tr>\n"
                        row_index += 1

                    packages += ("  </tbody>\n"
                                 "</table>\n")

                    data = path.read_text()
                    data = data.replace("<p>{website-packages}</p>",
                                        packages.to_string())
                    data = data.replace("{website-number-of-packages}",
                                        str(number_of_packages))
                    data = data.replace("{website-number-of-downloads}",
                                        str(number_of_downloads))
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_mys_version_activity(self, request: Request):
        match request.method:
            case "GET":
                path = self.database.make_path(request.path)

                if path.exists():
                    self.write_static_response_ok(path)
                    row_index = 0
                    activities = StringBuilder()
                    activities += (
                        "<table class=\"docutils align-default\">\n"
                        "  <thead>\n"
                        "    <tr class=\"row-odd\">\n"
                        "      <th class=\"head\">Date</th>\n"
                        "      <th class=\"head\">Message</th>\n"
                        "    </tr>\n"
                        "  </thead>\n"
                        "  <tbody>\n")

                    for activity in self._activities.recent():
                        if (row_index % 2) == 0:
                            activities += "    <tr class=\"row-even\">\n"
                        else:
                            activities += "    <tr class=\"row-odd\">\n"

                        activities += f"      <td>{activity.date}</td>\n"

                        match activity.kind:
                            case "📦":
                                message = make_package_link(activity.message)
                            case _:
                                message = activity.message

                        activities += f"      <td>{message}</td>\n"
                        activities += "    </tr>\n"
                        row_index += 1

                    activities += ("  </tbody>\n"
                                   "</table>\n")

                    data = path.read_text()
                    data = data.replace("<p>{website-activities}</p>",
                                        activities.to_string())
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_mys_version(self, request: Request):
        match request.method:
            case "GET":
                if ".." in request.path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(request.path)

                if path.exists():
                    self.write_static_response_ok(path)
                    self.client.write(path.read_binary())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_mys_standard_library(self, request: Request):
        mys = self.database.get_mys()

        if mys is not None:
            request.path = f"/{mys.latest_release.version}{request.path}"
            self.handle_mys_version_standard_library(request)
        else:
            self.write_response(Status.NotFound)

    func handle_mys_activity(self, request: Request):
        mys = self.database.get_mys()

        if mys is not None:
            request.path = f"/{mys.latest_release.version}{request.path}"
            self.handle_mys_version_activity(request)
        else:
            self.write_response(Status.NotFound)

    func handle_mys_version_statistics(self, request: Request):
        match request.method:
            case "GET":
                path = self.database.make_path(request.path)

                if path.exists():
                    requests, total_number_of_requests = create_request_table(
                        "requestsTable",
                        self.statistics.requests.count)
                    row_index = 0
                    referrers = StringBuilder()
                    referrers += (
                        "<table class=\"docutils align-default\">\n"
                        "  <thead>\n"
                        "    <tr class=\"row-odd\">\n"
                        "      <th class=\"head\">URL</th>\n"
                        "      <th class=\"head\">Count</th>\n"
                        "    </tr>\n"
                        "  </thead>\n"
                        "  <tbody>\n"
                    )

                    for url, count in self.statistics.referrers.count:
                        if (row_index % 2) == 0:
                            referrers += "    <tr class=\"row-even\">\n"
                        else:
                            referrers += "    <tr class=\"row-odd\">\n"

                        referrers += f"      <td><a href=\"{url}\">{url}</a></td>\n"
                        referrers += f"      <td>{count}</td>\n"
                        referrers += "    </tr>\n"
                        row_index += 1

                    referrers += (
                        "  </tbody>\n"
                        "</table>\n"
                    )

                    self.write_response_type(Status.Ok, "text/html")
                    data = path.read_text()
                    data = data.replace("{website-start-date-time}",
                                        str(self.statistics.start_date_time))
                    data = data.replace("{website-number-of-requests}",
                                        str(total_number_of_requests))
                    data = data.replace("<p>{website-requests}</p>", requests)
                    data = data.replace(
                        "{website-number-of-unique-visitors}",
                        self.statistics.unique_clients())
                    data = data.replace("<p>{website-referrers}</p>",
                                        referrers.to_string() + SORT_TABLE_JS)
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_mys_statistics(self, request: Request):
        mys = self.database.get_mys()

        if mys is not None:
            request.path = f"/{mys.latest_release.version}{request.path}"
            self.handle_mys_version_statistics(request)
        else:
            self.write_response(Status.NotFound)

    func handle_mys_world_svg(self, request: Request):
        mys = self.database.get_mys()

        if mys is not None:
            request.path = f"/{mys.latest_release.version}{request.path}"
            self.handle_mys_version_world_svg(request)
        else:
            self.write_response(Status.NotFound)

    func handle_standard_library_build_result(self,
                                             request: Request,
                                             package_name: string):
        match request.method:
            case "POST":
                content = self.read_post_content(1_000_000, request.headers)

                if content is None:
                    return

                builds = string(content)

                if builds in ["yes", "no"]:
                    self.database.set_package_builds(package_name, builds)
                    self.write_response(Status.Ok)
                else:
                    self.write_response(Status.BadRequest)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_standard_library_build_log(self,
                                          request: Request,
                                          package_name: string):
        path = self.database.make_path(request.path)

        match request.method:
            case "GET":
                if path.exists():
                    self.write_response(Status.Ok,
                                        headers={"Content-Type": "text/html"})
                    self.client.write(path.read_binary())
                else:
                    self.write_response(Status.NotFound)
            case "POST":
                package = self.database.get_package(package_name)

                if package is None:
                    self.write_response(Status.NotFound)
                    return

                content = self.read_post_content(5_000_000, request.headers)

                if content is None:
                    return

                log_path = self.database.make_path(f"standard-library/{package_name}")
                log_path.mkdir(exists_ok=True)
                path.write_binary(content)
                self.write_response(Status.Ok)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_standard_library_coverage_tar_gz(self,
                                                 request: Request,
                                                 package_name: string):
        match request.method:
            case "POST":
                package = self.database.get_package(package_name)

                if package is None:
                    self.write_response(Status.NotFound)
                    return

                fiber_path = self.save_post_data_to_file(5_000_000, request.headers)

                if fiber_path is None:
                    return

                coverage_path = self.database.make_path(
                    f"standard-library/{package_name}")
                coverage_path.mkdir(exists_ok=True)
                tar(fiber_path,
                    extract=True,
                    strip_components=2,
                    output_directory=coverage_path)
                self.write_response(Status.Ok)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_standard_library_coverage(self, request: Request):
        match request.method:
            case "GET":
                if ".." in request.path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(request.path)

                if path.exists():
                    self.write_static_response_ok(path)
                    self.client.write(path.read_binary())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_standard_library_dependents(self,
                                           request: Request,
                                           package_name: string):
        match request.method:
            case "GET":
                package = self.database.get_package(package_name)

                if package is None:
                    self.write_response(Status.NotFound)
                else:
                    dependents = self.database.get_dependents(package_name)

                    if len(dependents) > 0:
                        dependents.append("")

                    self.write_response(Status.Ok,
                                        data="\n".join(dependents).to_utf8())
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_standard_library_list(self, request: Request):
        match request.method:
            case "GET":
                packages = self.database.get_packages()
                self.write_response(Status.Ok, data="\n".join(packages).to_utf8())
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_graphql_post(self, request: Request):
        content = self.read_post_content(5_000, request.headers)

        if content is None:
            return

        self.statistics.number_of_graphql_requests += 1

        try:
            if "__schema" in string(content):
                path = Path(__assets__).join("schema.json")
                self.write_static_response_ok(path)
                self.client.write(path.read_binary())

                return
            else:
                decoded = json_decode(string(content)).get("query").get_string()
                document = graphql_parse(decoded)
                response = self._graphql.resolve_query(document)
        except Error as error:
            message = str(error).replace("\"", "'")
            response = f"{{\"errors\":[{{\"message\":\"{message}\"}}]}}"

        self.write_response(Status.Ok,
                            headers={"Content-Type": "application/json"},
                            data=response.to_utf8())

    func handle_graphql(self, request: Request):
        match request.method:
            case "POST":
                self.handle_graphql_post(request)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_mys_version_world_svg(self, request: Request):
        match request.method:
            case "GET":
                path = self.database.make_path(request.path)

                if path.exists():
                    locations = StringBuilder()

                    for _, location in self.statistics.locations:
                        # Just approximate x and y.
                        x = (112.0 / 360.0) * (180.0 + location.longitude)
                        y = 4.0 + (60.0 / 180.0) * (90.0 - location.latitude)

                        if location.response_status == Status.Ok:
                            href = "a"
                        else:
                            href = "b"

                        locations += (
                            f"""  <use href="#{href}" x="{x}" y="{y}" """
                            """style="opacity: 0.6"/>\n""")

                    self.write_response(Status.Ok,
                                        headers={"Content-Type": "image/svg+xml"})
                    world = path.read_text()
                    world = world.replace("  <!-- {website-world} -->",
                                          locations.to_string())
                    self.client.write(world.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_mys(self, request: Request):
        mys = self.database.get_mys()

        if mys is not None:
            request.path = f"/{mys.latest_release.version}{request.path}"
            self.handle_mys_version(request)
        else:
            self.write_response(Status.NotFound)

    func handle_package_operations(self, request: Request):
        match request.method:
            case "DELETE":
                package_name = request.path[9:]
                package = self.database.get_package(package_name)

                if package is None:
                    self.write_response(Status.NotFound)
                    return

                if not self.validate_token(request.params, package.token):
                    return

                self.database.delete_package(package)
                package_database_path = self.database.make_path(
                    f"package/{package_name}")
                package_database_path.rm(recursive=True, force=True)

                for release in package.releases:
                    release_database_path = self.database.make_path(
                        f"package/{package.name}-{release.version}.tar.gz")
                    release_database_path.rm(force=True)

                self.write_response(Status.Ok)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_package_latest(self, request: Request):
        parts = request.path.split('/')
        package_name = parts[2]
        package = self.database.get_package(package_name)

        if package is not None:
            request.path = request.path.replace("latest", package.latest_release.version)
            self.handle_mys_version(request)
        else:
            self.write_response(Status.NotFound)

    func handle_package(self, request: Request):
        match request.method:
            case "GET":
                if ".." in request.path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(request.path)

                if path.exists():
                    self.write_static_response_ok(path)
                    self.client.write(path.read_binary())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func generate_package_documentation(self,
                                       package_name: string,
                                       version: string):
        database_doc_path = self.database.make_path(
            f"package/{package_name}/{version}")
        database_doc_path.rm(recursive=True, force=True)
        database_doc_path.mkdir(exists_ok=True)

        if self.root_directory.join("doc").exists():
            try:
                run(f"mys -C {self.root_directory} doc")
                database_doc_path.rm()
                self.root_directory.join("build/doc/html").mv(database_doc_path)
            except OsError:
                data = b"<html>Package documentation build failed!</html>"
                database_doc_path.join("index.html").write_binary(data)
        else:
            data = b"<html>No package documentation found!</html>"
            database_doc_path.join("index.html").write_binary(data)

    func handle_package_tar_gz(self, request: Request, package_name: string):
        match request.method:
            case "GET":
                self.handle_package_tar_gz_get(package_name, request.path)
            case "POST":
                self.handle_package_tar_gz_post(request.path,
                                                request.params,
                                                request.headers)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_package_latest_tar_gz(self,
                                     request: Request,
                                     package_name: string):
        match request.method:
            case "GET":
                package = self.database.get_package(package_name)

                if package is not None:
                    version = package.latest_release.version
                    self.handle_package_tar_gz_get(
                        package_name,
                        f"/package/{package_name}-{version}.tar.gz")
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_package_tar_gz_get(self, package_name: string, path: string):
        database_path = self.database.make_path(path)

        if database_path.exists():
            data = database_path.read_binary()
            self.write_response(Status.Ok)
            self.client.write(data)
            self.database.increment_package_download_count(package_name)
        else:
            self.write_response(Status.NotFound)

    func read_post_content(self,
                          max_size: u64,
                          headers: {string: string}) -> bytes:
        content_length = u64(headers["content-length"])

        if content_length > max_size:
            self.write_response(Status.BadRequest)

            return None

        expect = headers.get("expect", "")

        if expect == "100-continue":
            self.write_response(Status.Continue)

        if content_length > 0:
            data = self._buffered_reader.read(content_length)

            if len(data) != content_length:
                self.write_response(Status.BadRequest)

                return None
        else:
            data = b""

        return data

    func save_post_data_to_file(self,
                               max_size: u64,
                               headers: {string: string}) -> Path:
        content = self.read_post_content(max_size, headers)

        if content is None:
            return None

        self.create_root_directory()
        fiber_path = self.make_path("archive.tar.gz")
        fiber_path.write_binary(content)

        return fiber_path

    func validate_token(self,
                       params: {string: string},
                       expected_token: string) -> bool:
        token = params.get("token", None)

        if token is None:
            self.write_response(Status.BadRequest)

            return False

        if token != expected_token:
            self.write_response(Status.Unauthorized)

            return False

        return True

    func handle_package_tar_gz_post(self,
                                   path: string,
                                   params: {string: string},
                                   headers: {string: string}):
        fiber_path = self.save_post_data_to_file(50_000_000, headers)

        if fiber_path is None:
            return

        tar(fiber_path,
            extract=True,
            strip_components=1,
            output_directory=self.root_directory)
        package_toml = self.make_path("package.toml").read_text()
        config = toml_decode(package_toml)
        package_name = config.get("package").get("name").get_string()
        version = config.get("package").get("version").get_string()

        try:
            description = config.get("package").get("description").get_string()
        except KeyError:
            description = "No description found."

        if package_name.match(RE_PACKAGE_NAME) is None:
            self.write_response(Status.BadRequest)
            return

        self.database.begin_transaction()
        response_data = ""
        created = False

        try:
            package = self.database.get_package(package_name)

            if package is None:
                self.database.create_package(package_name, create_token())
                package = self.database.get_package(package_name)
                response_data = f"{{\"token\": \"{package.token}\"}}"
                created = True
            elif not self.validate_token(params, package.token):
                self.database.rollback_transaction()
                return

            self.database.add_package_release(package, version, description)
            release = self.database.get_package_release(package, version)

            if package.latest_release is None:
                self.database.modify_package(package, release)
            elif Version(version) > Version(package.latest_release.version):
                self.database.modify_package(package, release)

            self.database.remove_dependents(package_name)

            try:
                for dependency in config.get("dependencies").get_table().keys():
                    self.database.add_dependent(dependency, package_name)
            except KeyError:
                pass

            self.database.commit_transaction()
        except:
            self.database.rollback_transaction()
            raise

        if created:
            self._activities.add("✨", f"Package {package_name} created!")

        database_path = self.database.make_path(path)
        database_path.rm(force=True)
        fiber_path.mv(database_path)
        self.generate_package_documentation(package_name, version)
        self.write_response(Status.Ok, data=response_data.to_utf8())
        self._activities.add(
            "📦",
            f"Package {package_name} version {version} released!")

    func handle_mys_tar_gz(self, request: Request):
        database_path = self.database.make_path(request.path)

        match request.method:
            case "POST":
                self.handle_mys_tar_gz_post(request, database_path)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func handle_mys_tar_gz_post(self, request: Request, database_path: Path):
        fiber_path = self.save_post_data_to_file(50_000_000, request.headers)

        if fiber_path is None:
            return

        version = request.path[5:-7]
        self.database.make_path(version).rm(recursive=True, force=True)
        tar(fiber_path,
            extract=True,
            output_directory=self.database.root_directory)

        self.database.begin_transaction()
        response_data = ""

        try:
            mys = self.database.get_mys()

            if mys is None:
                self.database.create_mys(create_token())
                mys = self.database.get_mys()
                response_data = f"{{\"token\": \"{mys.token}\"}}"
            elif not self.validate_token(request.params, mys.token):
                self.database.rollback_transaction()
                return

            self.database.add_mys_release(version)
            release = self.database.get_mys_release(version)

            if mys.latest_release is None:
                self.database.modify_mys(release)
            elif Version(version) > Version(mys.latest_release.version):
                self.database.modify_mys(release)

            self.database.commit_transaction()
        except:
            self.database.rollback_transaction()
            raise

        self.write_response(Status.Ok, data=response_data.to_utf8())
        self._activities.add("🐭", f"Mys version {version} released!")

    func handle_static_file(self, request: Request):
        match request.method:
            case "GET":
                path = Path(__assets__).join(request.path)

                if path.exists() and ".." not in str(path):
                    self.write_static_response_ok(path)
                    self.client.write(path.read_binary())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    func write_response(self,
                       status: Status,
                       headers: {string: string} = {},
                       data: bytes = None):
        self.response_status = status
        status_string = STATUS_STRINGS[i64(status)]
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n".to_utf8())

        for name, value in headers:
            self.client.write(f"{name}: {value}\r\n".to_utf8())

        if data is None:
            self.client.write(b"\r\n")
        else:
            self.client.write(f"Content-Length: {len(data)}\r\n\r\n".to_utf8())
            self.client.write(data)

    func write_static_response_ok(self, path: Path):
        content_type = FILE_SUFFIX_TO_CONTENT_TYPE.get(path.extension(), "text/plain")

        if content_type == "text/html":
            self.write_response_type(Status.Ok, content_type)
        else:
            self.write_response(Status.Ok,
                                headers={
                                    "Cache-Control": "public, max-age=7200",
                                    "Content-Type": content_type
                                })

    func write_response_type(self, status: Status, content_type: string):
        self.write_response(status,
                            headers={"Content-Type": content_type})
