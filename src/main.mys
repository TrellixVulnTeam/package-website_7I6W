from argparse import Parser
from net.tcp.server import Server
from net.tcp.server import Client
from os import BinaryFile
from os import TextFile
from os import tar
from os import exists
from os import mkdir
from os.subprocess import run
from os import rm
from os import OsError
from .database import Database
from .database import Package
from .database import Release
from .database import Mys
from .database import MysRelease
from toml import decode as toml_decode
from toml import Value as TomlValue
from fiber import Fiber
from fiber import Event

class ReadError(Error):
    pass

@enum
class Status:
    Continue = 100
    Ok = 200
    Found = 302
    BadRequest = 400
    NotFound = 404
    MethodNotAllowed = 405

_STATUS_STRINGS: {i64: string} = {
    i64(Status.Continue): "Continue",
    i64(Status.Ok): "OK",
    i64(Status.Found): "Found",
    i64(Status.BadRequest): "Bad Request",
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

class ClientHandlerFiber(Fiber):
    database: Database
    event: Event
    client: Client
    client_handlers: [ClientHandlerFiber]
    root_directory: string

    def __init__(self,
                 database: Database,
                 client_handlers: [ClientHandlerFiber],
                 index: i64):
        self.database = database
        self.client_handlers = client_handlers
        self.root_directory = f".website/{index}"
        self.event = Event()
        self.client = None
        self.create_root_directory()

    def create_root_directory(self):
        rm(self.root_directory, recursive=True, force=True)
        mkdir(self.root_directory, exists_ok=True)

    def run(self):
        while True:
            self.event.wait()
            self.event.clear()

            try:
                self.serve()
            except Error as e:
                print(e)

            self.client.disconnect()
            self.client_handlers += self

    def make_path(self, path: string) -> string:
        """Prepend the database root directory path to given path. Given path
        must not start with a slash.

        """

        return f"{self.root_directory}/{path}"

    def read_line(self) -> string:
        line = b""

        while True:
            byte = self.client.read(1)

            if len(byte) != 1:
                raise ReadError()

            line += byte

            if len(line) < 2:
                continue

            if line[-2] == u8('\r') and line[-1] == u8('\n'):
                break

        return string(line)[:-2]

    def read_request_line(self) -> (string, string, string):
        line = self.read_line()
        mo = line.match(re"^(\w+) ([^? ]+)\??(.*) HTTP/1.1$")

        if mo is None:
            print("Bad request line:", line)

            return None

        return (mo.group(1), mo.group(2), mo.group(3))

    def read_headers(self) -> {string: string}:
        headers: {string: string} = {}

        while True:
            line = self.read_line()

            if len(line) == 0:
                break

            mo = line.match(re"^([^:]+): (.*)$")

            if mo is not None:
                headers[mo.group(1)] = mo.group(2)

        return headers

    def serve(self):
        request = self.read_request_line()

        if request is None:
            self.write_response(Status.BadRequest)

            return

        method, path, params = request
        headers = self.read_headers()

        print(method, path, params)

        if path == "/":
            self.handle_index(method)
        elif path.match(re"/\d+\.\d+\.\d+[\w-]*/standard-library.html") is not None:
            self.handle_mys_version_standard_library(method, path)
        elif path.match(re"/\d+\.\d+\.\d+[\w-]*/") is not None:
            self.handle_mys_version(method, path)
        elif path.match(re"^/package/[\w-]+-\d+\.\d+\.\d+[\w-]*.tar.gz$") is not None:
            self.handle_package_tar_gz(method, path, headers)
        elif path.match(re"^/package/[\w-]+-latest.tar.gz$") is not None:
            self.handle_package_latest_tar_gz(method, path)
        elif path.starts_with("/package/"):
            self.handle_package(method, path)
        elif path.match(re"^/mys-\d+\.\d+\.\d+[\w-]*.tar.gz$") is not None:
            self.handle_mys_tar_gz(method, path, headers)
        elif path == "/favicon.ico":
            self.handle_static_file(method, path)
        elif path == "/standard-library.html":
            self.handle_mys_standard_library(method, path)
        else:
            self.handle_mys(method, path)

    def handle_index(self, method: string):
        match method:
            case "GET":
                mys = self.database.get_mys()

                if mys.latest_release is not None:
                    self.handle_mys(method, "/index.html")
                else:
                    self.write_response(Status.Ok)
                    self.client.write(b"<html>No mys documentation found!</html>")
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_version_standard_library(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    packages = ""

                    for package_name in self.database.get_packages():
                        package = self.database.get_package(package_name)
                        version = package.latest_release.version
                        database_doc_path = (
                            f"/package/{package_name}/{version}/index.html")
                        packages += (
                            f"<li><p><a href=\"{database_doc_path}\">"
                            f"{package_name}</a> - "
                            f"{package.latest_release.description}</p></li>\n")

                    data = TextFile(path).read()
                    data = data.replace("<li><p>{website-package}</p></li>", packages)
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_version(self, method: string, path: string):
        match method:
            case "GET":
                if ".." in path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_standard_library(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_standard_library(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_package(self, method: string, path: string):
        match method:
            case "GET":
                if ".." in path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def generate_package_documentation(self,
                                       package_name: string,
                                       version: string):
        database_doc_path = self.database.make_path(
            f"package/{package_name}/{version}")
        rm(database_doc_path, recursive=True, force=True)
        mkdir(database_doc_path, exists_ok=True)

        if exists(f"{self.root_directory}/doc"):
            try:
                run(f"mys -C {self.root_directory} doc")
                run(f"mv {self.root_directory}/build/doc/html/* "
                    f"{database_doc_path}")
            except OsError:
                data = b"<html>Package documentation build failed!</html>"
                BinaryFile(f"{database_doc_path}/index.html", "w").write(data)
        else:
            data = b"<html>No package documentation found!</html>"
            BinaryFile(f"{database_doc_path}/index.html", "w").write(data)

    def handle_package_tar_gz(self,
                              method: string,
                              path: string,
                              headers: {string: string}):
        database_path = self.database.make_path(path[1:])

        match method:
            case "GET":
                self.handle_package_tar_gz_get(database_path)
            case "POST":
                self.handle_package_tar_gz_post(path, headers, database_path)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_latest_tar_gz(self, method: string, path: string):
        match method:
            case "GET":
                package_name = path[9:-14]
                package = self.database.get_package(package_name)

                if package is not None and package.latest_release is not None:
                    version = package.latest_release.version
                    path = f"package/{package_name}-{version}.tar.gz"
                    self.handle_package_tar_gz_get(self.database.make_path(path))
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_tar_gz_get(self, database_path: string):
        if exists(database_path):
            data = BinaryFile(database_path).read()
            self.write_response(Status.Ok)
            self.client.write(data)
        else:
            self.write_response(Status.NotFound)

    def handle_package_tar_gz_post(self,
                                   path: string,
                                   headers: {string: string},
                                   database_path: string):
        content_length = u32(headers["Content-Length"])

        if content_length > 1_000_000:
            self.write_response(Status.BadRequest)
            return

        expect = headers.get("Expect", "")

        if expect == "100-continue":
            self.write_response(Status.Continue)

        data = self.client.read(content_length)
        self.create_root_directory()
        fiber_path = self.make_path("archive.tar.gz")
        BinaryFile(fiber_path, "w").write(data)
        tar(fiber_path,
            extract=True,
            strip_components=1,
            output_directory=self.root_directory)
        package_toml = TextFile(self.make_path("package.toml")).read()
        config = toml_decode(package_toml)
        package_name = config.get("package").get("name").get_string()
        version = config.get("package").get("version").get_string()

        try:
            description = config.get("package").get("description").get_string()
        except KeyError:
            description = "No description found."

        if package_name.match(re"^[\w\-]+$") is None:
            self.write_response(Status.BadRequest)
            return

        package = self.database.get_package(package_name)

        if package is None:
            self.database.create_package(package_name)
            package = self.database.get_package(package_name)

        self.database.add_package_release(package, version, description)
        release = self.database.get_package_release(package, version)

        if package.latest_release is None:
            self.database.modify_package(package, release)
        else:
            finder = LatestVersionFinder()
            finder.add(version)
            finder.add(package.latest_release.version)

            if finder.latest == version:
                self.database.modify_package(package, release)

        run(f"mv {fiber_path} {database_path}")
        self.generate_package_documentation(package_name, version)
        self.write_response(Status.Ok)

    def handle_mys_tar_gz(self,
                          method: string,
                          path: string,
                          headers: {string: string}):
        database_path = self.database.make_path(path[1:])

        match method:
            case "POST":
                self.handle_mys_tar_gz_post(path, headers, database_path)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_tar_gz_post(self,
                               path: string,
                               headers: {string: string},
                               database_path: string):
        content_length = u32(headers["Content-Length"])

        if content_length > 50_000_000:
            self.write_response(Status.BadRequest)
            return

        expect = headers.get("Expect", "")

        if expect == "100-continue":
            self.write_response(Status.Continue)

        data = self.client.read(content_length)
        fiber_path = self.make_path("archive.tar.gz")
        BinaryFile(fiber_path, "w").write(data)
        version = path[5:-7]
        rm(self.database.make_path(version), recursive=True, force=True)
        tar(fiber_path,
            extract=True,
            output_directory=self.database.root_directory)
        mys = self.database.get_mys()
        self.database.add_mys_release(version)
        release = self.database.get_mys_release(version)

        if mys.latest_release is None:
            self.database.modify_mys(release)
        else:
            finder = LatestVersionFinder()
            finder.add(version)
            finder.add(mys.latest_release.version)

            if finder.latest == version:
                self.database.modify_mys(release)

        self.write_response(Status.Ok)

    def handle_static_file(self, method: string, path: string):
        match method:
            case "GET":
                path = f"{__assets__}{path}"

                if exists(path) and ".." not in path:
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def write_response(self, status: Status, headers: {string: string} = {}):
        status_string = _STATUS_STRINGS[i64(status)]
        print(status, status_string)
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n".to_utf8())

        for name, value in headers:
            self.client.write(f"{name}: {value}\r\n".to_utf8())

        self.client.write("\r\n".to_utf8())

    def write_static_response_ok(self, path: string):
        if path.ends_with(".html"):
            self.write_response(Status.Ok)
        else:
            self.write_response(Status.Ok,
                                headers={
                                    "Cache-Control": "public, max-age=7200"
                                })

class LatestVersionFinder:
    latest: string
    _latest: (i64, i64, i64)

    def __init__(self):
        self.latest = None

    def add(self, version: string):
        mo = version.match(re"^(\d+)\.(\d+)\.(\d+)$")

        if mo is None:
            return

        major = i64(mo.group(1))
        minor = i64(mo.group(2))
        revision = i64(mo.group(3))

        if self.latest is None:
            self.latest = version
            self._latest = (major, minor, revision)

            return

        if major < self._latest[0]:
            return
        elif major == self._latest[0]:
            if minor < self._latest[1]:
                return
            elif minor == self._latest[1]:
                if revision < self._latest[2]:
                    return

        self.latest = version
        self._latest = (major, minor, revision)

def main(argv: [string]):
    parser = Parser("website")
    parser.add_option("--port",
                      short="-p",
                      default="8000",
                      help="Port to listen for clients on (default: 8000).")
    parser.add_option("--database-directory",
                      short="-d",
                      default=".",
                      help="Database directory (default: \".\").")
    args = parser.parse(argv)

    database = Database(args.value_of("--database-directory"))

    client_handlers: [ClientHandlerFiber] = []

    for i in range(20):
        client_handlers += ClientHandlerFiber(database, client_handlers, i)
        client_handlers[-1].start()

    server = Server()
    port = u32(args.value_of("--port"))
    server.listen(port)

    print(f"Listening for clients on port {port}.")

    while True:
        client = server.accept()

        if len(client_handlers) > 0:
            client_handler = client_handlers.pop()
            client_handler.client = client
            client_handler.event.set()
        else:
            print("No client handler available.")
