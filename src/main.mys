from argparse import Parser
from net.tcp.server import Server
from net.tcp.server import Client
from os import BinaryFile
from os import TextFile
from os import tar
from os import exists
from os import mkdir
from os.subprocess import run
from os import rm
from os import mv
from os import OsError
from .database import Database
from .database import Package
from .database import Release
from .database import Mys
from .database import MysRelease
from toml import decode as toml_decode
from toml import Value as TomlValue
from fiber import Fiber
from fiber import Event
from . import create_token
from . import parse_params
from .version import is_later_version
from .statistics import Statistics
from string import StringBuilder

RE_REQUEST: regex = re"^(\w+) ([^? ]+)\??(.*) HTTP/1.1$"
RE_HEADER_LINE: regex = re"^([^:]+): (.*)$"
RE_MYS_VERSION_STANDARD_LIBRARY: regex = (
    re"^/\d+\.\d+\.\d+[\w-]*/standard-library.html")
RE_MYS_VERSION_STATISTICS: regex = re"^/\d+\.\d+\.\d+[\w-]*/statistics.html"
RE_MYS_VERSION_WORLD_SVG: regex = re"^/\d+\.\d+\.\d+[\w-]*/_images/world.svg"
RE_MYS_VERSION: regex = re"^/\d+\.\d+\.\d+[\w-]*/"
RE_PACKAGE_TAR_GZ: regex = re"^/package/([\w-]+)-\d+\.\d+\.\d+[\w-]*.tar.gz$"
RE_PACKAGE_LATEST_TAR_GZ: regex = re"^/package/[\w-]+-latest.tar.gz$"
RE_PACKAGE_OPERATIONS: regex = re"^/package/[\w-]+$"
RE_PACKAGE_LATEST: regex = re"^/package/[\w-]+/latest/"
RE_MYS_TAR_GZ: regex = re"^/mys-\d+\.\d+\.\d+[\w-]*.tar.gz$"
RE_PACKAGE_NAME: regex = re"^[\w\-]+$"

FILE_SUFFIX_TO_CONTENT_TYPE: {string: string} = {
    "html": "text/html",
    "css": "text/css",
    "js": "application/javascript",
    "svg": "image/svg+xml",
    "png": "image/png",
    "woff2": "font/woff2"
}

class ReadError(Error):
    pass

@enum
class Status:
    Continue = 100
    Ok = 200
    Found = 302
    BadRequest = 400
    Unauthorized = 401
    NotFound = 404
    MethodNotAllowed = 405

_STATUS_STRINGS: {i64: string} = {
    i64(Status.Continue): "Continue",
    i64(Status.Ok): "OK",
    i64(Status.Found): "Found",
    i64(Status.BadRequest): "Bad Request",
    i64(Status.Unauthorized): "Unauthorized",
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

class ClientHandlerFiber(Fiber):
    database: Database
    statistics: Statistics
    event: Event
    client: Client
    client_handlers: [ClientHandlerFiber]
    root_directory: string

    def __init__(self,
                 database: Database,
                 statistics: Statistics,
                 client_handlers: [ClientHandlerFiber],
                 index: i64):
        self.database = database
        self.statistics = statistics
        self.client_handlers = client_handlers
        self.root_directory = f".website/{index}"
        self.event = Event()
        self.client = None
        self.create_root_directory()

    def create_root_directory(self):
        rm(self.root_directory, recursive=True, force=True)
        mkdir(self.root_directory, exists_ok=True)

    def run(self):
        while True:
            self.event.wait()
            self.event.clear()

            try:
                self.serve()
            except Error as e:
                print(e)

            self.client.disconnect()
            self.client_handlers += self

    def make_path(self, path: string) -> string:
        """Prepend the database root directory path to given path. Given path
        must not start with a slash.

        """

        return f"{self.root_directory}/{path}"

    def read_line(self) -> string:
        line = b""

        while True:
            byte = self.client.read(1)

            if len(byte) != 1:
                raise ReadError()

            line += byte

            if len(line) < 2:
                continue

            if line[-2] == u8('\r') and line[-1] == u8('\n'):
                break

        return string(line)[:-2]

    def read_request_line(self) -> (string, string, string):
        line = self.read_line()
        mo = line.match(RE_REQUEST)

        if mo is None:
            print("Bad request line:", line)

            return None

        return (mo.group(1), mo.group(2), mo.group(3))

    def read_headers(self) -> {string: string}:
        headers: {string: string} = {}

        while True:
            line = self.read_line()

            if len(line) == 0:
                break

            mo = line.match(RE_HEADER_LINE)

            if mo is not None:
                headers[mo.group(1)] = mo.group(2)

        return headers

    def serve(self):
        request = self.read_request_line()

        if request is None:
            self.write_response(Status.BadRequest)
            return

        method, path, params_string = request
        params = parse_params(params_string)
        headers = self.read_headers()

        self.statistics.handle_request(method,
                                       path,
                                       headers.get("X-Forwarded-For", None))

        # print(method, path, params_string)

        if path == "/":
            self.handle_index(method)
            return

        if path.match(RE_MYS_VERSION_STANDARD_LIBRARY) is not None:
            self.handle_mys_version_standard_library(method, path)
            return

        if path.match(RE_MYS_VERSION_STATISTICS) is not None:
            self.handle_mys_version_statistics(method, path)
            return

        if path.match(RE_MYS_VERSION_WORLD_SVG) is not None:
            self.handle_mys_version_world_svg(method, path)
            return

        if path.match(RE_MYS_VERSION) is not None:
            self.handle_mys_version(method, path)
            return

        mo = path.match(RE_PACKAGE_TAR_GZ)

        if mo is not None:
            self.handle_package_tar_gz(method, path, params, headers, mo.group(1))
            return

        if path.match(RE_PACKAGE_LATEST_TAR_GZ) is not None:
            self.handle_package_latest_tar_gz(method, path)
            return

        if path.match(RE_PACKAGE_OPERATIONS) is not None:
            self.handle_package_operations(method, path, params)
            return

        if path.match(RE_PACKAGE_LATEST) is not None:
            self.handle_package_latest(method, path)
            return

        if path.starts_with("/package/"):
            self.handle_package(method, path)
            return

        if path.match(RE_MYS_TAR_GZ) is not None:
            self.handle_mys_tar_gz(method, path, params, headers)
            return

        if path == "/favicon.ico":
            self.handle_static_file(method, path)
            return

        if path == "/standard-library.html":
            self.handle_mys_standard_library(method, path)
            return

        if path == "/statistics.html":
            self.handle_mys_statistics(method, path)
            return

        if path == "/_images/world.svg":
            self.handle_mys_world_svg(method, path)
            return

        self.handle_mys(method, path)

    def handle_index(self, method: string):
        match method:
            case "GET":
                mys = self.database.get_mys()

                if mys is not None:
                    self.handle_mys(method, "/index.html")
                else:
                    self.write_response_type(Status.Ok, "text/html")
                    self.client.write(b"<html>No mys documentation found!</html>")
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_version_standard_library(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    row_index = 0
                    packages = StringBuilder()
                    packages += (
                        "<table class=\"docutils align-default\">\n"
                        "  <colgroup>\n"
                        "    <col/>\n"
                        "    <col/>\n"
                        "    <col/>\n"
                        "  </colgroup>\n"
                        "  <thead>\n"
                        "    <tr class=\"row-odd\">\n"
                        "      <th class=\"head\">Name</th>\n"
                        "      <th class=\"head\">Description</th>\n"
                        "      <th class=\"head\">Version</th>\n"
                        "      <th class=\"head\">Downloads</th>\n"
                        "    </tr>\n"
                        "  </thead>\n"
                        "  <tbody>\n"
                    )
                    number_of_packages = 0
                    number_of_downloads = 0

                    for package_name in self.database.get_packages():
                        package = self.database.get_package(package_name)
                        number_of_packages += 1
                        number_of_downloads += package.number_of_downloads
                        database_doc_path = (
                            f"/package/{package_name}/latest/index.html")

                        if (row_index % 2) == 0:
                            packages += "    <tr class=\"row-even\">\n"
                        else:
                            packages += "    <tr class=\"row-odd\">\n"

                        packages += (
                            f"      <td><a href=\"{database_doc_path}\">"
                            f"{package_name}</a></td>\n")
                        packages += (
                            f"      <td>{package.latest_release.description}</td>\n")
                        packages += f"      <td>{package.latest_release.version}</td>\n"
                        packages += f"      <td>{package.number_of_downloads}</td>\n"
                        packages += "    </tr>\n"
                        row_index += 1

                    packages += ("  </tbody>\n"
                                 "</table>\n")

                    data = TextFile(path).read()
                    data = data.replace("<p>{website-packages}</p>", packages.to_string())
                    data = data.replace("{website-number-of-packages}",
                                        str(number_of_packages))
                    data = data.replace("{website-number-of-downloads}",
                                        str(number_of_downloads))
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_version(self, method: string, path: string):
        match method:
            case "GET":
                if ".." in path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_standard_library(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_standard_library(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys_version_statistics(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    total_number_of_requests = 0
                    row_index = 0
                    requests = StringBuilder()
                    requests += (
                        "<table class=\"docutils align-default\" "
                        "id=\"requestsTable\">\n"
                        "  <colgroup>\n"
                        "    <col/>\n"
                        "    <col/>\n"
                        "    <col/>\n"
                        "  </colgroup>\n"
                        "  <thead>\n"
                        "    <tr class=\"row-odd\">\n"
                        "      <th class=\"head\" onclick=\"sortTable(0)\">"
                        "Path</th>\n"
                        "      <th class=\"head\" onclick=\"sortTable(1)\">"
                        "Method</th>\n"
                        "      <th class=\"head\" onclick=\"sortTable(2)\">"
                        "Count</th>\n"
                        "    </tr>\n"
                        "  </thead>\n"
                        "  <tbody>\n"
                    )

                    for line, count in self.statistics.requests:
                        total_number_of_requests += count
                        pos = line.find(' ')
                        method = line[:pos]
                        request_path = line[pos + 1:]

                        if (row_index % 2) == 0:
                            requests += "    <tr class=\"row-even\">\n"
                        else:
                            requests += "    <tr class=\"row-odd\">\n"

                        requests += f"      <td>{request_path}</td>\n"
                        requests += f"      <td>{method}</td>\n"
                        requests += f"      <td>{count}</td>\n"
                        requests += "    </tr>\n"
                        row_index += 1

                    requests += (
                        "  </tbody>\n"
                        "</table>\n"
                        "<script>\n"
                        "function sortTable(n) {\n"
                        "  var table, rows, switching, i, x, y;\n"
                        "  var shouldSwitch, dir, switchcount = 0;\n"
                        "  table = document.getElementById(\"requestsTable\");\n"
                        "  switching = true;\n"
                        "  dir = \"asc\";\n"
                        "  while (switching) {\n"
                        "    switching = false;\n"
                        "    rows = table.rows;\n"
                        "    for (i = 1; i < (rows.length - 1); i++) {\n"
                        "      shouldSwitch = false;\n"
                        "      x = rows[i].getElementsByTagName(\"TD\")[n].innerHTML;\n"
                        "      y = rows[i + 1].getElementsByTagName(\"TD\")[n]"
                        ".innerHTML;\n"
                        "      if (dir == \"asc\") {\n"
                        "        if (((n < 2) && (x > y))\n"
                        "            || ((n == 2) && (parseInt(x) > parseInt(y)))) {\n"
                        "          shouldSwitch = true;\n"
                        "          break;\n"
                        "        }\n"
                        "      } else if (dir == \"desc\") {\n"
                        "        if (((n < 2) && (x < y))\n"
                        "            || ((n == 2) && (parseInt(x) < parseInt(y)))) {\n"
                        "          shouldSwitch = true;\n"
                        "          break;\n"
                        "        }\n"
                        "      }\n"
                        "    }\n"
                        "    if (shouldSwitch) {\n"
                        "      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);\n"
                        "      switching = true;\n"
                        "      switchcount++;\n"
                        "    } else {\n"
                        "      if (switchcount == 0 && dir == \"asc\") {\n"
                        "        dir = \"desc\";\n"
                        "        switching = true;\n"
                        "      }\n"
                        "    }\n"
                        "  }\n"
                        "}\n"
                        "</script>\n"
                    )

                    self.write_static_response_ok(path)
                    data = TextFile(path).read()
                    data = data.replace("{website-start-date-time}",
                                        str(self.statistics.start_date_time))
                    data = data.replace("{website-number-of-views}",
                                        str(total_number_of_requests))
                    data = data.replace(
                        "{website-number-of-unique-visitors}",
                        str(len(self.statistics.clients_ip_addresses)))
                    data = data.replace("<p>{website-requests}</p>",
                                        requests.to_string())
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_statistics(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_statistics(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys_world_svg(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_world_svg(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys_version_world_svg(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    locations = StringBuilder()

                    for _, location in self.statistics.locations:
                        # Just approximate x and y.
                        x = (112.0 / 360.0) * (180.0 + location.longitude)
                        y = 4.0 + (60.0 / 180.0) * (90.0 - location.latitude)
                        locations += (
                            f"""  <use href="#a" x="{x}" y="{y}" """
                            """style="opacity: 0.6"/>\n""")

                    self.write_response(Status.Ok,
                                        headers={"Content-Type": "image/svg+xml"})
                    world = TextFile(path).read()
                    world = world.replace("  <!-- {website-world} -->",
                                          locations.to_string())
                    self.client.write(world.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_package_operations(self,
                                  method: string,
                                  path: string,
                                  params: {string: string}):
        match method:
            case "DELETE":
                package_name = path[9:]
                package = self.database.get_package(package_name)

                if package is None:
                    self.write_response(Status.NotFound)
                    return

                if not self.validate_token(params, package.token):
                    return

                self.database.delete_package(package)
                package_database_path = self.database.make_path(
                    f"package/{package_name}")
                rm(package_database_path, recursive=True, force=True)

                for release in package.releases:
                    release_database_path = self.database.make_path(
                        f"package/{package.name}-{release.version}.tar.gz")
                    rm(release_database_path, force=True)

                self.write_response(Status.Ok)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_latest(self, method: string, path: string):
        parts = path.split('/')
        package_name = parts[2]
        package = self.database.get_package(package_name)

        if package is not None:
            path = path.replace("latest", package.latest_release.version)
            self.handle_mys_version(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_package(self, method: string, path: string):
        match method:
            case "GET":
                if ".." in path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def generate_package_documentation(self,
                                       package_name: string,
                                       version: string):
        database_doc_path = self.database.make_path(
            f"package/{package_name}/{version}")
        rm(database_doc_path, recursive=True, force=True)
        mkdir(database_doc_path, exists_ok=True)

        if exists(f"{self.root_directory}/doc"):
            try:
                run(f"mys -C {self.root_directory} doc")
                rm(database_doc_path)
                mv(f"{self.root_directory}/build/doc/html", database_doc_path)
            except OsError:
                data = b"<html>Package documentation build failed!</html>"
                BinaryFile(f"{database_doc_path}/index.html", "w").write(data)
        else:
            data = b"<html>No package documentation found!</html>"
            BinaryFile(f"{database_doc_path}/index.html", "w").write(data)

    def handle_package_tar_gz(self,
                              method: string,
                              path: string,
                              params: {string: string},
                              headers: {string: string},
                              package_name: string):
        database_path = self.database.make_path(path[1:])

        match method:
            case "GET":
                self.handle_package_tar_gz_get(package_name, database_path)
            case "POST":
                self.handle_package_tar_gz_post(path, params, headers, database_path)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_latest_tar_gz(self, method: string, path: string):
        match method:
            case "GET":
                package_name = path[9:-14]
                package = self.database.get_package(package_name)

                if package is not None:
                    version = package.latest_release.version
                    path = f"package/{package_name}-{version}.tar.gz"
                    self.handle_package_tar_gz_get(package_name,
                                                   self.database.make_path(path))
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_tar_gz_get(self, package_name: string, database_path: string):
        if exists(database_path):
            data = BinaryFile(database_path).read()
            self.write_response(Status.Ok)
            self.client.write(data)
            self.database.increment_package_download_count(package_name)
        else:
            self.write_response(Status.NotFound)

    def save_post_data_to_file(self,
                               max_size: i64,
                               headers: {string: string}) -> string:
        content_length = u32(headers["Content-Length"])

        if content_length > 50_000_000:
            self.write_response(Status.BadRequest)

            return None

        expect = headers.get("Expect", "")

        if expect == "100-continue":
            self.write_response(Status.Continue)

        data = self.client.read(content_length)
        self.create_root_directory()
        fiber_path = self.make_path("archive.tar.gz")
        BinaryFile(fiber_path, "w").write(data)

        return fiber_path

    def validate_token(self,
                       params: {string: string},
                       expected_token: string) -> bool:
        token = params.get("token", None)

        if token is None:
            self.write_response(Status.BadRequest)

            return False

        if token != expected_token:
            self.write_response(Status.Unauthorized)

            return False

        return True

    def handle_package_tar_gz_post(self,
                                   path: string,
                                   params: {string: string},
                                   headers: {string: string},
                                   database_path: string):
        fiber_path = self.save_post_data_to_file(1_000_000, headers)

        if fiber_path is None:
            return

        tar(fiber_path,
            extract=True,
            strip_components=1,
            output_directory=self.root_directory)
        package_toml = TextFile(self.make_path("package.toml")).read()
        config = toml_decode(package_toml)
        package_name = config.get("package").get("name").get_string()
        version = config.get("package").get("version").get_string()

        try:
            description = config.get("package").get("description").get_string()
        except KeyError:
            description = "No description found."

        if package_name.match(RE_PACKAGE_NAME) is None:
            self.write_response(Status.BadRequest)
            return

        self.database.begin_transaction()
        response_data = ""

        try:
            package = self.database.get_package(package_name)

            if package is None:
                self.database.create_package(package_name, create_token())
                package = self.database.get_package(package_name)
                response_data = f"{{\"token\": \"{package.token}\"}}"
            elif not self.validate_token(params, package.token):
                self.database.rollback_transaction()
                return

            self.database.add_package_release(package, version, description)
            release = self.database.get_package_release(package, version)

            if package.latest_release is None:
                self.database.modify_package(package, release)
            elif is_later_version(version, package.latest_release.version):
                self.database.modify_package(package, release)

            self.database.commit_transaction()
        except:
            self.database.rollback_transaction()
            raise

        rm(database_path, force=True)
        mv(fiber_path, database_path)
        self.generate_package_documentation(package_name, version)
        self.write_response(Status.Ok, data=response_data)

    def handle_mys_tar_gz(self,
                          method: string,
                          path: string,
                          params: {string: string},
                          headers: {string: string}):
        database_path = self.database.make_path(path[1:])

        match method:
            case "POST":
                self.handle_mys_tar_gz_post(path, params, headers, database_path)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_tar_gz_post(self,
                               path: string,
                               params: {string: string},
                               headers: {string: string},
                               database_path: string):
        fiber_path = self.save_post_data_to_file(50_000_000, headers)

        if fiber_path is None:
            return

        version = path[5:-7]
        rm(self.database.make_path(version), recursive=True, force=True)
        tar(fiber_path,
            extract=True,
            output_directory=self.database.root_directory)

        self.database.begin_transaction()
        response_data = ""

        try:
            mys = self.database.get_mys()

            if mys is None:
                self.database.create_mys(create_token())
                mys = self.database.get_mys()
                response_data = f"{{\"token\": \"{mys.token}\"}}"
            elif not self.validate_token(params, mys.token):
                self.database.rollback_transaction()
                return

            self.database.add_mys_release(version)
            release = self.database.get_mys_release(version)

            if mys.latest_release is None:
                self.database.modify_mys(release)
            elif is_later_version(version, mys.latest_release.version):
                self.database.modify_mys(release)

            self.database.commit_transaction()
        except:
            self.database.rollback_transaction()
            raise

        self.write_response(Status.Ok, data=response_data)

    def handle_static_file(self, method: string, path: string):
        match method:
            case "GET":
                path = f"{__assets__}{path}"

                if exists(path) and ".." not in path:
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def write_response(self,
                       status: Status,
                       headers: {string: string} = {},
                       data: string = None):
        status_string = _STATUS_STRINGS[i64(status)]
        # print(status, status_string)
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n".to_utf8())

        for name, value in headers:
            self.client.write(f"{name}: {value}\r\n".to_utf8())

        if data is None:
            self.client.write("\r\n".to_utf8())
        else:
            data_bytes = data.to_utf8()
            self.client.write(f"Content-Length: {len(data_bytes)}\r\n\r\n".to_utf8())
            self.client.write(data_bytes)

    def write_static_response_ok(self, path: string):
        content_type = FILE_SUFFIX_TO_CONTENT_TYPE.get(path.split('.')[-1], "text/plain")

        if content_type == "html":
            self.write_response_type(Status.Ok, content_type)
        else:
            self.write_response(Status.Ok,
                                headers={
                                    "Cache-Control": "public, max-age=7200",
                                    "Content-Type": content_type
                                })

    def write_response_type(self, status: Status, content_type: string):
        self.write_response(status,
                            headers={"Content-Type": content_type})

def main(argv: [string]):
    parser = Parser("website")
    parser.add_option("--port",
                      short="-p",
                      default="8000",
                      help="Port to listen for clients on (default: 8000).")
    parser.add_option("--database-directory",
                      short="-d",
                      default=".",
                      help="Database directory (default: \".\").")
    parser.add_option("--ipinfo-token",
                      short="-i",
                      takes_value=True,
                      help="ipinfo.io token.")
    args = parser.parse(argv)

    database = Database(args.value_of("--database-directory"))
    statistics = Statistics(args.value_of("--ipinfo-token"))

    client_handlers: [ClientHandlerFiber] = []

    for i in range(20):
        client_handlers += ClientHandlerFiber(database,
                                              statistics,
                                              client_handlers,
                                              i)
        client_handlers[-1].start()

    server = Server()
    port = u32(args.value_of("--port"))
    server.listen(port)

    print(f"Listening for clients on port {port}.")

    while True:
        client = server.accept()

        if len(client_handlers) > 0:
            client_handler = client_handlers.pop()
            client_handler.client = client
            client_handler.event.set()
        else:
            print("No client handler available.")
