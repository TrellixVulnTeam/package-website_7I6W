from argparse import Parser
from net.tcp.server import Server
from net.tcp.server import Client
from os import BinaryFile
from os import TextFile
from os import tar
from os import exists
from os import mkdir
from os.subprocess import run
from os import rm
from os import mv
from os import OsError
from .database import Database
from .database import Package
from .database import Release
from .database import Mys
from .database import MysRelease
from toml import decode as toml_decode
from toml import Value as TomlValue
from fiber import Fiber
from fiber import Event
from . import create_token
from . import parse_params
from semver import Version
from .statistics import Statistics
from string import StringBuilder

RE_REQUEST: regex = re"^(\w+) ([^? ]+)\??(.*) HTTP/1.1$"
RE_HEADER_LINE: regex = re"^([^:]+): (.*)$"
RE_MYS_VERSION_STANDARD_LIBRARY: regex = (
    re"^/\d+\.\d+\.\d+[\w-]*/standard-library.html")
RE_MYS_VERSION_STATISTICS: regex = re"^/\d+\.\d+\.\d+[\w-]*/statistics.html"
RE_MYS_VERSION_WORLD_SVG: regex = re"^/\d+\.\d+\.\d+[\w-]*/_images/world.svg"
RE_MYS_VERSION: regex = re"^/\d+\.\d+\.\d+[\w-]*/"
RE_PACKAGE_TAR_GZ: regex = re"^/package/([\w-]+)-\d+\.\d+\.\d+[\w-]*.tar.gz$"
RE_PACKAGE_LATEST_TAR_GZ: regex = re"^/package/([\w-]+)-latest.tar.gz$"
RE_PACKAGE_OPERATIONS: regex = re"^/package/[\w-]+$"
RE_PACKAGE_LATEST: regex = re"^/package/[\w-]+/latest/"
RE_MYS_TAR_GZ: regex = re"^/mys-\d+\.\d+\.\d+[\w-]*.tar.gz$"
RE_PACKAGE_NAME: regex = re"^[\w\-]+$"

FILE_SUFFIX_TO_CONTENT_TYPE: {string: string} = {
    "html": "text/html",
    "css": "text/css",
    "js": "application/javascript",
    "svg": "image/svg+xml",
    "png": "image/png",
    "woff2": "font/woff2"
}

HEADER_END: bytes = b"\r\n"
HEADERS_END: bytes = b"\r\n\r\n"

class ReadError(Error):
    pass

@enum
class Status:
    Continue = 100
    Ok = 200
    Found = 302
    BadRequest = 400
    Unauthorized = 401
    NotFound = 404
    MethodNotAllowed = 405
    Unknown = 1000

_STATUS_STRINGS: {i64: string} = {
    i64(Status.Continue): "Continue",
    i64(Status.Ok): "OK",
    i64(Status.Found): "Found",
    i64(Status.BadRequest): "Bad Request",
    i64(Status.Unauthorized): "Unauthorized",
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

def create_request_table(name: string, requests: {string: i64}) -> (string, i64):
    total_number_of_requests = 0
    row_index = 0
    builder = StringBuilder()
    builder += (
        "<table class=\"docutils align-default\" "
        f"id=\"{name}\">\n"
        "  <colgroup>\n"
        "    <col/>\n"
        "    <col/>\n"
        "    <col/>\n"
        "  </colgroup>\n"
        "  <thead>\n"
        "    <tr class=\"row-odd\">\n"
        f"      <th class=\"head\" onclick=\"sortTable(0, '{name}')\">"
        "Path</th>\n"
        f"      <th class=\"head\" onclick=\"sortTable(1, '{name}')\">"
        "Method</th>\n"
        f"      <th class=\"head\" onclick=\"sortTable(2, '{name}')\">"
        "Count</th>\n"
        "    </tr>\n"
        "  </thead>\n"
        "  <tbody>\n"
    )

    for line, count in requests:
        total_number_of_requests += count
        pos = line.find(' ')
        method = line[:pos]
        request_path = line[pos + 1:]

        if (row_index % 2) == 0:
            builder += "    <tr class=\"row-even\">\n"
        else:
            builder += "    <tr class=\"row-odd\">\n"

        builder += f"      <td>{request_path}</td>\n"
        builder += f"      <td>{method}</td>\n"
        builder += f"      <td>{count}</td>\n"
        builder += "    </tr>\n"
        row_index += 1

    builder += (
        "  </tbody>\n"
        "</table>\n"
    )

    return builder.to_string(), total_number_of_requests

_SORT_TABLE_JS: string = """\
<script>
function sortTable(n, element) {
  var table, rows, switching, i, x, y;
  var shouldSwitch, dir, switchcount = 0;
  table = document.getElementById(element);
  switching = true;
  dir = \"asc\";
  while (switching) {
    switching = false;
    rows = table.rows;
    for (i = 1; i < (rows.length - 1); i++) {
      shouldSwitch = false;
      x = rows[i].getElementsByTagName(\"TD\")[n].innerHTML;
      y = rows[i + 1].getElementsByTagName(\"TD\")[n].innerHTML;
      if (dir == \"asc\") {
        if (((n < 2) && (x > y))
            || ((n == 2) && (parseInt(x) > parseInt(y)))) {
          shouldSwitch = true;
          break;
        }
      } else if (dir == \"desc\") {
        if (((n < 2) && (x < y))
            || ((n == 2) && (parseInt(x) < parseInt(y)))) {
          shouldSwitch = true;
          break;
        }
      }
    }
    if (shouldSwitch) {
      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);
      switching = true;
      switchcount++;
    } else {
      if (switchcount == 0 && dir == \"asc\") {
        dir = \"desc\";
        switching = true;
      }
    }
  }
}
</script>
"""

class ClientHandlerFiber(Fiber):
    database: Database
    statistics: Statistics
    event: Event
    client: Client
    client_handlers: [ClientHandlerFiber]
    root_directory: string
    response_status: Status
    _header: bytes
    _header_offset: i64
    _header_size: i64
    _data_size: i64

    def __init__(self,
                 database: Database,
                 statistics: Statistics,
                 client_handlers: [ClientHandlerFiber],
                 index: i64):
        self.database = database
        self.statistics = statistics
        self.client_handlers = client_handlers
        self.root_directory = f".website/{index}"
        self.event = Event()
        self.client = None
        self.create_root_directory()
        self.response_status = Status.Unknown
        self._header = bytes(2048)

    def create_root_directory(self):
        rm(self.root_directory, recursive=True, force=True)
        mkdir(self.root_directory, exists_ok=True)

    def run(self):
        while True:
            self.event.wait()
            self.event.clear()

            try:
                self.serve()
            except Error as e:
                print(e)

            self.client.disconnect()
            self.client_handlers.append(self)

    def make_path(self, path: string) -> string:
        """Prepend the database root directory path to given path. Given path
        must not start with a slash.

        """

        return f"{self.root_directory}/{path}"

    def read_header(self):
        offset: u64 = 0

        while True:
            size = self.client.try_read_into(self._header,
                                             offset,
                                             len(self._header) - offset)

            if size == 0:
                raise ReadError()

            if offset < 4:
                overlap = offset
            else:
                overlap = u64(4)

            self._header_size = self._header.find(HEADERS_END,
                                                  i64(offset - overlap),
                                                  i64(size + overlap))
            offset += size

            if self._header_size != -1:
                self._header_offset = 0
                self._header_size += 4
                self._data_size = i64(offset) - self._header_size
                break

    def read_line(self) -> string:
        pos = self._header.find(HEADER_END, self._header_offset, self._header_size)
        offset = self._header_offset
        self._header_offset = pos + 2

        return string(self._header, offset, pos)

    def read_request_line(self) -> (string, string, string):
        line = self.read_line()
        mo = line.match(RE_REQUEST)

        if mo is None:
            return None

        return (mo.group(1), mo.group(2), mo.group(3))

    def read_headers(self) -> {string: string}:
        headers: {string: string} = {}

        while True:
            line = self.read_line()

            if len(line) == 0:
                break

            mo = line.match(RE_HEADER_LINE)

            if mo is not None:
                headers[mo.group(1).lower()] = mo.group(2)

        return headers

    def handle_request(self,
                       method: string,
                       path: string,
                       params: {string: string},
                       headers: {string: string}):
        self.response_status = Status.Unknown

        if path == "/":
            path = "/index.html"

        if path.match(RE_MYS_VERSION_STANDARD_LIBRARY) is not None:
            self.handle_mys_version_standard_library(method, path)
            return

        if path.match(RE_MYS_VERSION_STATISTICS) is not None:
            self.handle_mys_version_statistics(method, path)
            return

        if path.match(RE_MYS_VERSION_WORLD_SVG) is not None:
            self.handle_mys_version_world_svg(method, path)
            return

        if path.match(RE_MYS_VERSION) is not None:
            self.handle_mys_version(method, path)
            return

        mo = path.match(RE_PACKAGE_TAR_GZ)

        if mo is not None:
            self.handle_package_tar_gz(method, path, params, headers, mo.group(1))
            return

        mo = path.match(RE_PACKAGE_LATEST_TAR_GZ)

        if mo is not None:
            self.handle_package_latest_tar_gz(method, mo.group(1))
            return

        if path.match(RE_PACKAGE_OPERATIONS) is not None:
            self.handle_package_operations(method, path, params)
            return

        if path.match(RE_PACKAGE_LATEST) is not None:
            self.handle_package_latest(method, path)
            return

        if path.starts_with("/package/"):
            self.handle_package(method, path)
            return

        if path.match(RE_MYS_TAR_GZ) is not None:
            self.handle_mys_tar_gz(method, path, params, headers)
            return

        if path == "/favicon.ico":
            self.handle_static_file(method, path)
            return

        if path == "/standard-library.html":
            self.handle_mys_standard_library(method, path)
            return

        if path == "/statistics.html":
            self.handle_mys_statistics(method, path)
            return

        if path == "/_images/world.svg":
            self.handle_mys_world_svg(method, path)
            return

        self.handle_mys(method, path)

    def serve(self):
        self.read_header()
        request = self.read_request_line()

        if request is None:
            self.write_response(Status.BadRequest)
            return

        method, path, params_string = request
        params = parse_params(params_string)
        headers = self.read_headers()

        try:
            self.handle_request(method, path, params, headers)
        finally:
            self.statistics.handle_request(method,
                                           path,
                                           self.response_status,
                                           headers.get("x-forwarded-for", None),
                                           headers.get("referer", None))

    def handle_mys_version_standard_library(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    row_index = 0
                    packages = StringBuilder()
                    packages += (
                        "<table class=\"docutils align-default\">\n"
                        "  <colgroup>\n"
                        "    <col/>\n"
                        "    <col/>\n"
                        "    <col/>\n"
                        "  </colgroup>\n"
                        "  <thead>\n"
                        "    <tr class=\"row-odd\">\n"
                        "      <th class=\"head\">Name</th>\n"
                        "      <th class=\"head\">Description</th>\n"
                        "      <th class=\"head\">Version</th>\n"
                        "      <th class=\"head\">Downloads</th>\n"
                        "    </tr>\n"
                        "  </thead>\n"
                        "  <tbody>\n"
                    )
                    number_of_packages = 0
                    number_of_downloads = 0

                    for package_name in self.database.get_packages():
                        package = self.database.get_package(package_name)
                        number_of_packages += 1
                        number_of_downloads += package.number_of_downloads
                        database_doc_path = (
                            f"/package/{package_name}/latest/index.html")

                        if (row_index % 2) == 0:
                            packages += "    <tr class=\"row-even\">\n"
                        else:
                            packages += "    <tr class=\"row-odd\">\n"

                        packages += (
                            f"      <td><a href=\"{database_doc_path}\">"
                            f"{package_name}</a></td>\n")
                        packages += (
                            f"      <td>{package.latest_release.description}</td>\n")
                        packages += f"      <td>{package.latest_release.version}</td>\n"
                        packages += f"      <td>{package.number_of_downloads}</td>\n"
                        packages += "    </tr>\n"
                        row_index += 1

                    packages += ("  </tbody>\n"
                                 "</table>\n")

                    data = TextFile(path).read()
                    data = data.replace("<p>{website-packages}</p>", packages.to_string())
                    data = data.replace("{website-number-of-packages}",
                                        str(number_of_packages))
                    data = data.replace("{website-number-of-downloads}",
                                        str(number_of_downloads))
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_version(self, method: string, path: string):
        match method:
            case "GET":
                if ".." in path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_standard_library(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_standard_library(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys_version_statistics(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    requests, total_number_of_requests = create_request_table(
                        "requestsTable",
                        self.statistics.requests.count)
                    not_found_requests, _ = create_request_table(
                        "notFoundRequestsTable",
                        self.statistics.not_found_requests.count)
                    row_index = 0
                    referrers = StringBuilder()
                    referrers += (
                        "<table class=\"docutils align-default\">\n"
                        "  <colgroup>\n"
                        "    <col/>\n"
                        "    <col/>\n"
                        "  </colgroup>\n"
                        "  <thead>\n"
                        "    <tr class=\"row-odd\">\n"
                        "      <th class=\"head\">URL</th>\n"
                        "      <th class=\"head\">Count</th>\n"
                        "    </tr>\n"
                        "  </thead>\n"
                        "  <tbody>\n"
                    )

                    for url, count in self.statistics.referrers.count:
                        if (row_index % 2) == 0:
                            referrers += "    <tr class=\"row-even\">\n"
                        else:
                            referrers += "    <tr class=\"row-odd\">\n"

                        referrers += f"      <td>{url}</td>\n"
                        referrers += f"      <td>{count}</td>\n"
                        referrers += "    </tr>\n"
                        row_index += 1

                    referrers += (
                        "  </tbody>\n"
                        "</table>\n"
                    )

                    self.write_response_type(Status.Ok, "text/html")
                    data = TextFile(path).read()
                    data = data.replace("{website-start-date-time}",
                                        str(self.statistics.start_date_time))
                    data = data.replace("{website-number-of-requests}",
                                        str(total_number_of_requests))
                    data = data.replace("<p>{website-requests}</p>", requests)
                    data = data.replace(
                        "{website-number-of-unique-visitors}",
                        str(len(self.statistics.clients_ip_addresses)))
                    data = data.replace("<p>{website-referrers}</p>",
                                        referrers.to_string())
                    data = data.replace("<p>{website-not-found-requests}</p>",
                                        not_found_requests + _SORT_TABLE_JS)
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_statistics(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_statistics(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys_world_svg(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_world_svg(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys_version_world_svg(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    locations = StringBuilder()

                    for _, location in self.statistics.locations:
                        # Just approximate x and y.
                        x = (112.0 / 360.0) * (180.0 + location.longitude)
                        y = 4.0 + (60.0 / 180.0) * (90.0 - location.latitude)

                        if location.response_status == Status.Ok:
                            href = "a"
                        else:
                            href = "b"

                        locations += (
                            f"""  <use href="#{href}" x="{x}" y="{y}" """
                            """style="opacity: 0.6"/>\n""")

                    self.write_response(Status.Ok,
                                        headers={"Content-Type": "image/svg+xml"})
                    world = TextFile(path).read()
                    world = world.replace("  <!-- {website-world} -->",
                                          locations.to_string())
                    self.client.write(world.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_package_operations(self,
                                  method: string,
                                  path: string,
                                  params: {string: string}):
        match method:
            case "DELETE":
                package_name = path[9:]
                package = self.database.get_package(package_name)

                if package is None:
                    self.write_response(Status.NotFound)
                    return

                if not self.validate_token(params, package.token):
                    return

                self.database.delete_package(package)
                package_database_path = self.database.make_path(
                    f"package/{package_name}")
                rm(package_database_path, recursive=True, force=True)

                for release in package.releases:
                    release_database_path = self.database.make_path(
                        f"package/{package.name}-{release.version}.tar.gz")
                    rm(release_database_path, force=True)

                self.write_response(Status.Ok)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_latest(self, method: string, path: string):
        parts = path.split('/')
        package_name = parts[2]
        package = self.database.get_package(package_name)

        if package is not None:
            path = path.replace("latest", package.latest_release.version)
            self.handle_mys_version(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_package(self, method: string, path: string):
        match method:
            case "GET":
                if ".." in path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def generate_package_documentation(self,
                                       package_name: string,
                                       version: string):
        database_doc_path = self.database.make_path(
            f"package/{package_name}/{version}")
        rm(database_doc_path, recursive=True, force=True)
        mkdir(database_doc_path, exists_ok=True)

        if exists(f"{self.root_directory}/doc"):
            try:
                run(f"mys -C {self.root_directory} doc")
                rm(database_doc_path)
                mv(f"{self.root_directory}/build/doc/html", database_doc_path)
            except OsError:
                data = b"<html>Package documentation build failed!</html>"
                BinaryFile(f"{database_doc_path}/index.html", "w").write(data)
        else:
            data = b"<html>No package documentation found!</html>"
            BinaryFile(f"{database_doc_path}/index.html", "w").write(data)

    def handle_package_tar_gz(self,
                              method: string,
                              path: string,
                              params: {string: string},
                              headers: {string: string},
                              package_name: string):
        match method:
            case "GET":
                self.handle_package_tar_gz_get(package_name, path)
            case "POST":
                self.handle_package_tar_gz_post(path, params, headers)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_latest_tar_gz(self,
                                     method: string,
                                     package_name: string):
        match method:
            case "GET":
                package = self.database.get_package(package_name)

                if package is not None:
                    version = package.latest_release.version
                    self.handle_package_tar_gz_get(
                        package_name,
                        f"/package/{package_name}-{version}.tar.gz")
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_tar_gz_get(self, package_name: string, path: string):
        database_path = self.database.make_path(path[1:])

        if exists(database_path):
            data = BinaryFile(database_path).read()
            self.write_response(Status.Ok)
            self.client.write(data)
            self.database.increment_package_download_count(package_name)
        else:
            self.write_response(Status.NotFound)

    def save_post_data_to_file(self,
                               max_size: i64,
                               headers: {string: string}) -> string:
        content_length = u64(headers["content-length"])

        if content_length > 50_000_000:
            self.write_response(Status.BadRequest)

            return None

        expect = headers.get("expect", "")

        if expect == "100-continue":
            self.write_response(Status.Continue)

        data = bytes(self._data_size)

        for i in range(self._data_size):
            data[i] = self._header[self._header_size + i]

        content_length -= len(data)

        if content_length > 0:
            data += self.client.read(content_length)

        self.create_root_directory()
        fiber_path = self.make_path("archive.tar.gz")
        BinaryFile(fiber_path, "w").write(data)

        return fiber_path

    def validate_token(self,
                       params: {string: string},
                       expected_token: string) -> bool:
        token = params.get("token", None)

        if token is None:
            self.write_response(Status.BadRequest)

            return False

        if token != expected_token:
            self.write_response(Status.Unauthorized)

            return False

        return True

    def handle_package_tar_gz_post(self,
                                   path: string,
                                   params: {string: string},
                                   headers: {string: string}):
        fiber_path = self.save_post_data_to_file(1_000_000, headers)

        if fiber_path is None:
            return

        tar(fiber_path,
            extract=True,
            strip_components=1,
            output_directory=self.root_directory)
        package_toml = TextFile(self.make_path("package.toml")).read()
        config = toml_decode(package_toml)
        package_name = config.get("package").get("name").get_string()
        version = config.get("package").get("version").get_string()

        try:
            description = config.get("package").get("description").get_string()
        except KeyError:
            description = "No description found."

        if package_name.match(RE_PACKAGE_NAME) is None:
            self.write_response(Status.BadRequest)
            return

        self.database.begin_transaction()
        response_data = ""

        try:
            package = self.database.get_package(package_name)

            if package is None:
                self.database.create_package(package_name, create_token())
                package = self.database.get_package(package_name)
                response_data = f"{{\"token\": \"{package.token}\"}}"
            elif not self.validate_token(params, package.token):
                self.database.rollback_transaction()
                return

            self.database.add_package_release(package, version, description)
            release = self.database.get_package_release(package, version)

            if package.latest_release is None:
                self.database.modify_package(package, release)
            elif Version(version) > Version(package.latest_release.version):
                self.database.modify_package(package, release)

            self.database.commit_transaction()
        except:
            self.database.rollback_transaction()
            raise

        database_path = self.database.make_path(path[1:])
        rm(database_path, force=True)
        mv(fiber_path, database_path)
        self.generate_package_documentation(package_name, version)
        self.write_response(Status.Ok, data=response_data.to_utf8())

    def handle_mys_tar_gz(self,
                          method: string,
                          path: string,
                          params: {string: string},
                          headers: {string: string}):
        database_path = self.database.make_path(path[1:])

        match method:
            case "POST":
                self.handle_mys_tar_gz_post(path, params, headers, database_path)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_tar_gz_post(self,
                               path: string,
                               params: {string: string},
                               headers: {string: string},
                               database_path: string):
        fiber_path = self.save_post_data_to_file(50_000_000, headers)

        if fiber_path is None:
            return

        version = path[5:-7]
        rm(self.database.make_path(version), recursive=True, force=True)
        tar(fiber_path,
            extract=True,
            output_directory=self.database.root_directory)

        self.database.begin_transaction()
        response_data = ""

        try:
            mys = self.database.get_mys()

            if mys is None:
                self.database.create_mys(create_token())
                mys = self.database.get_mys()
                response_data = f"{{\"token\": \"{mys.token}\"}}"
            elif not self.validate_token(params, mys.token):
                self.database.rollback_transaction()
                return

            self.database.add_mys_release(version)
            release = self.database.get_mys_release(version)

            if mys.latest_release is None:
                self.database.modify_mys(release)
            elif Version(version) > Version(mys.latest_release.version):
                self.database.modify_mys(release)

            self.database.commit_transaction()
        except:
            self.database.rollback_transaction()
            raise

        self.write_response(Status.Ok, data=response_data.to_utf8())

    def handle_static_file(self, method: string, path: string):
        match method:
            case "GET":
                path = f"{__assets__}{path}"

                if exists(path) and ".." not in path:
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def write_response(self,
                       status: Status,
                       headers: {string: string} = {},
                       data: bytes = None):
        self.response_status = status
        status_string = _STATUS_STRINGS[i64(status)]
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n".to_utf8())

        for name, value in headers:
            self.client.write(f"{name}: {value}\r\n".to_utf8())

        if data is None:
            self.client.write(b"\r\n")
        else:
            self.client.write(f"Content-Length: {len(data)}\r\n\r\n".to_utf8())
            self.client.write(data)

    def write_static_response_ok(self, path: string):
        content_type = FILE_SUFFIX_TO_CONTENT_TYPE.get(path.split('.')[-1],
                                                       "text/plain")

        if content_type == "text/html":
            self.write_response_type(Status.Ok, content_type)
        else:
            self.write_response(Status.Ok,
                                headers={
                                    "Cache-Control": "public, max-age=7200",
                                    "Content-Type": content_type
                                })

    def write_response_type(self, status: Status, content_type: string):
        self.write_response(status,
                            headers={"Content-Type": content_type})

def main(argv: [string]):
    parser = Parser("website")
    parser.add_option("--port",
                      short="-p",
                      default="8000",
                      help="Port to listen for clients on (default: 8000).")
    parser.add_option("--database-directory",
                      short="-d",
                      default=".",
                      help="Database directory (default: \".\").")
    parser.add_option("--ipinfo-token",
                      short="-i",
                      takes_value=True,
                      help="ipinfo.io token.")
    args = parser.parse(argv)

    database = Database(args.value_of("--database-directory"))
    statistics = Statistics(args.value_of("--ipinfo-token"))

    client_handlers: [ClientHandlerFiber] = []

    for i in range(20):
        client_handlers.append(ClientHandlerFiber(database,
                                                  statistics,
                                                  client_handlers,
                                                  i))
        client_handlers[-1].start()

    server = Server()
    port = u32(args.value_of("--port"))
    server.listen(port)

    print(f"Listening for clients on port {port}.")

    while True:
        client = server.accept()

        if len(client_handlers) > 0:
            client_handler = client_handlers.pop()
            client_handler.client = client
            client_handler.event.set()
        else:
            print("No client handler available.")
