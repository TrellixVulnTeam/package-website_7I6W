from argparse import Parser
from net.tcp.server import Server
from net.tcp.server import Client
from os import BinaryFile

class ClientError(Error):
    pass

@enum
class Status:
    NotFound = 404
    MethodNotAllowed = 405

_STATUS_STRINGS: {i64: string} = {
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

class HttpClient:
    client: Client

    def read_line(self) -> string:
        line = b""

        while True:
            byte = self.client.read(1)

            if len(byte) != 1:
                raise ClientError()

            line += byte

            if len(line) < 2:
                continue

            if line[-2] == u8('\r') and line[-1] == u8('\n'):
                break

        return string(line)[:-2]

    def read_request_line(self) -> (string, string):
        line = self.read_line()
        mo = line.match(re"^(\w+) (.+) HTTP/1.1$")

        if mo is None:
            return None

        return (mo.group(1), mo.group(2))

    def read_headers(self) -> {string: string}:
        headers: {string: string} = {}

        while True:
            line = self.read_line()

            if len(line) == 0:
                break

            mo = line.match(re"^([^:]+): (.*)$")

            if mo is not None:
                headers[mo.group(1)] = mo.group(2)

        return headers

    def run(self):
        method, path = self.read_request_line()
        headers = self.read_headers()

        if path == "/":
            self.handle_index(method)
        elif path.match(re"^/package/[^/]+.tar.gz$") is not None:
            self.handle_package_archive(method, path, headers)
        elif path.starts_with("/package/"):
            self.handle_package(method, path)
        else:
            self.send_error(Status.NotFound)

    def handle_index(self, method: string):
        match method:
            case "GET":
                self.client.write("HTTP/1.1 200 OK\r\n"
                                  "\r\n".to_utf8())
                self.client.write(BinaryFile("src/static/index.html").read())
            case _:
                self.send_error(Status.MethodNotAllowed)

    def handle_package(self, method: string, path: string):
        package_name = path.strip_left("/package/")

        match method:
            case "GET":
                if package_name in ["os", "random", "sqlite"]:
                    self.client.write("HTTP/1.1 200 OK\r\n"
                                      "\r\n".to_utf8())
                    self.client.write(
                        "<html>"
                        f"  <title>{package_name}</title>"
                        f"   Some information about the {package_name} package."
                        "</html>".to_utf8())
                else:
                    self.send_error(Status.NotFound)
            case _:
                self.send_error(Status.MethodNotAllowed)


    def handle_package_archive(self,
                               method: string,
                               path: string,
                               headers: {string: string}):
        path = path.strip_left("/")

        match method:
            case "GET":
                data = BinaryFile(path).read()
                self.client.write("HTTP/1.1 200 OK\r\n"
                                  "\r\n".to_utf8())
                self.client.write(data)
            case "POST":
                data = self.client.read(u32(headers["Content-Length"]))
                # BinaryFile(path, "w").write(data)
                self.client.write("HTTP/1.1 200 OK\r\n"
                                  "\r\n".to_utf8())
            case _:
                self.send_error(Status.MethodNotAllowed)

    def send_error(self, status: Status):
        status_string = _STATUS_STRINGS[i64(status)]
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n"
                          "\r\n".to_utf8())

def main(argv: [string]):
    parser = Parser("website")
    parser.add_option("--port",
                      default="8000",
                      help="Port to listen for clients on (default: 8000).")
    args = parser.parse(argv)

    server = Server()
    port = u32(args.value_of("--port"))
    server.listen(port)

    print(f"Listening for clients on port {port}")

    while True:
        client = server.accept()

        try:
            HttpClient(client).run()
        except:
            pass

        client.disconnect()
