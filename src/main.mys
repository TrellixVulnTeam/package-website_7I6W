from argparse import Parser
from net.tcp.server import Server
from net.tcp.server import Client
from os import BinaryFile
from os import TextFile
from os import tar
from os import exists
from os import mkdir
from os.subprocess import run
from os import rm
from os import OsError
from .database import Database
from .database import Package
from .database import Release
from .database import Mys
from .database import MysRelease
from toml import decode as toml_decode
from toml import Value as TomlValue
from fiber import Fiber
from fiber import Event
from . import create_token
from . import parse_params
from .version import is_later_version
from time import LocalDateTime

class ReadError(Error):
    pass

@enum
class Status:
    Continue = 100
    Ok = 200
    Found = 302
    BadRequest = 400
    Unauthorized = 401
    NotFound = 404
    MethodNotAllowed = 405

_STATUS_STRINGS: {i64: string} = {
    i64(Status.Continue): "Continue",
    i64(Status.Ok): "OK",
    i64(Status.Found): "Found",
    i64(Status.BadRequest): "Bad Request",
    i64(Status.Unauthorized): "Unauthorized",
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

class ClientHandlerFiber(Fiber):
    database: Database
    statistics: Statistics
    event: Event
    client: Client
    client_handlers: [ClientHandlerFiber]
    root_directory: string

    def __init__(self,
                 database: Database,
                 statistics: Statistics,
                 client_handlers: [ClientHandlerFiber],
                 index: i64):
        self.database = database
        self.statistics = statistics
        self.client_handlers = client_handlers
        self.root_directory = f".website/{index}"
        self.event = Event()
        self.client = None
        self.create_root_directory()

    def create_root_directory(self):
        rm(self.root_directory, recursive=True, force=True)
        mkdir(self.root_directory, exists_ok=True)

    def run(self):
        while True:
            self.event.wait()
            self.event.clear()

            try:
                self.serve()
            except Error as e:
                print(e)

            self.client.disconnect()
            self.client_handlers += self

    def make_path(self, path: string) -> string:
        """Prepend the database root directory path to given path. Given path
        must not start with a slash.

        """

        return f"{self.root_directory}/{path}"

    def read_line(self) -> string:
        line = b""

        while True:
            byte = self.client.read(1)

            if len(byte) != 1:
                raise ReadError()

            line += byte

            if len(line) < 2:
                continue

            if line[-2] == u8('\r') and line[-1] == u8('\n'):
                break

        return string(line)[:-2]

    def read_request_line(self) -> (string, string, string):
        line = self.read_line()
        mo = line.match(re"^(\w+) ([^? ]+)\??(.*) HTTP/1.1$")

        if mo is None:
            print("Bad request line:", line)

            return None

        return (mo.group(1), mo.group(2), mo.group(3))

    def read_headers(self) -> {string: string}:
        headers: {string: string} = {}

        while True:
            line = self.read_line()

            if len(line) == 0:
                break

            mo = line.match(re"^([^:]+): (.*)$")

            if mo is not None:
                headers[mo.group(1)] = mo.group(2)

        return headers

    def serve(self):
        request = self.read_request_line()

        if request is None:
            self.write_response(Status.BadRequest)

            return

        method, path, params_string = request
        self.statistics.handle_request(method, path)
        params = parse_params(params_string)
        headers = self.read_headers()

        print(method, path, params_string)

        if path == "/":
            self.handle_index(method)
        elif path.match(re"^/\d+\.\d+\.\d+[\w-]*/standard-library.html") is not None:
            self.handle_mys_version_standard_library(method, path)
        elif path.match(re"^/\d+\.\d+\.\d+[\w-]*/statistics.html") is not None:
            self.handle_mys_version_statistics(method, path)
        elif path.match(re"^/\d+\.\d+\.\d+[\w-]*/") is not None:
            self.handle_mys_version(method, path)
        elif path.match(re"^/package/[\w-]+-\d+\.\d+\.\d+[\w-]*.tar.gz$") is not None:
            self.handle_package_tar_gz(method, path, params, headers)
        elif path.match(re"^/package/[\w-]+-latest.tar.gz$") is not None:
            self.handle_package_latest_tar_gz(method, path)
        elif path.match(re"^/package/[\w-]+$") is not None:
            self.handle_package_operations(method, path, params)
        elif path.match(re"^/package/[\w-]+/latest/") is not None:
            self.handle_package_latest(method, path)
        elif path.starts_with("/package/"):
            self.handle_package(method, path)
        elif path.match(re"^/mys-\d+\.\d+\.\d+[\w-]*.tar.gz$") is not None:
            self.handle_mys_tar_gz(method, path, params, headers)
        elif path == "/favicon.ico":
            self.handle_static_file(method, path)
        elif path == "/standard-library.html":
            self.handle_mys_standard_library(method, path)
        elif path == "/statistics.html":
            self.handle_mys_statistics(method, path)
        else:
            self.handle_mys(method, path)

    def handle_index(self, method: string):
        match method:
            case "GET":
                mys = self.database.get_mys()

                if mys is not None:
                    self.handle_mys(method, "/index.html")
                else:
                    self.write_response(Status.Ok)
                    self.client.write(b"<html>No mys documentation found!</html>")
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_version_standard_library(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    packages = ""

                    for package_name in self.database.get_packages():
                        package = self.database.get_package(package_name)
                        database_doc_path = (
                            f"/package/{package_name}/latest/index.html")
                        packages += (
                            f"<li><p><a href=\"{database_doc_path}\">"
                            f"{package_name}</a> - "
                            f"{package.latest_release.description}</p></li>\n")

                    data = TextFile(path).read()
                    data = data.replace("<li><p>{website-package}</p></li>", packages)
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_version(self, method: string, path: string):
        match method:
            case "GET":
                if ".." in path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_standard_library(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_standard_library(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys_version_statistics(self, method: string, path: string):
        match method:
            case "GET":
                path = self.database.make_path(path[1:])

                if exists(path):
                    total_number_of_requests = 0
                    requests_lines: [string] = []
                    row_index = 0

                    for line, count in self.statistics.requests:
                        total_number_of_requests += count
                        pos = line.find(' ')
                        method = line[:pos]
                        request_path = line[pos + 1:]

                        if (row_index % 2) == 0:
                            requests_lines += "    <tr class=\"row-even\">"
                        else:
                            requests_lines += "    <tr class=\"row-odd\">"

                        requests_lines += f"      <td>{request_path}</td>"
                        requests_lines += f"      <td>{method}</td>"
                        requests_lines += f"      <td>{count}</td>"
                        requests_lines += "    </tr>"
                        row_index += 1

                    requests = "\n".join([
                        "<table class=\"docutils align-default\" id=\"requestsTable\">",
                        "  <colgroup>",
                        "    <col/>",
                        "    <col/>",
                        "    <col/>",
                        "  </colgroup>",
                        "  <thead>",
                        "    <tr class=\"row-odd\">",
                        "      <th class=\"head\" onclick=\"sortTable(0)\"><p>Path</p></th>",
                        "      <th class=\"head\" onclick=\"sortTable(1)\"><p>Method</p></th>",
                        "      <th class=\"head\" onclick=\"sortTable(2)\"><p>Count</p></th>",
                        "    </tr>",
                        "  </thead>",
                        "  <tbody>"
                    ] + requests_lines + [
                        "  </tbody>",
                        "</table>",
                        "<script>",
                        "function sortTable(n) {",
                        "  var table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;",
                        "  table = document.getElementById(\"requestsTable\");",
                        "  switching = true;",
                        "  dir = \"asc\";",
                        "  while (switching) {",
                        "    switching = false;",
                        "    rows = table.rows;",
                        "    for (i = 1; i < (rows.length - 1); i++) {",
                        "      shouldSwitch = false;",
                        "      x = rows[i].getElementsByTagName(\"TD\")[n].innerHTML;",
                        "      y = rows[i + 1].getElementsByTagName(\"TD\")[n].innerHTML;",
                        "      if (dir == \"asc\") {",
                        "        if (((n < 2) && (x > y)) || ((n == 2) && (parseInt(x) > parseInt(y)))) {",
                        "          shouldSwitch = true;",
                        "          break;",
                        "        }",
                        "      } else if (dir == \"desc\") {",
                        "        if (((n < 2) && (x < y)) || ((n == 2) && (parseInt(x) < parseInt(y)))) {",
                        "          shouldSwitch = true;",
                        "          break;",
                        "        }",
                        "      }",
                        "    }",
                        "    if (shouldSwitch) {",
                        "      rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);",
                        "      switching = true;",
                        "      switchcount++;",
                        "    } else {",
                        "      if (switchcount == 0 && dir == \"asc\") {",
                        "        dir = \"desc\";",
                        "        switching = true;",
                        "      }",
                        "    }",
                        "  }",
                        "}",
                        "</script>"
                    ])

                    self.write_static_response_ok(path)
                    data = TextFile(path).read()
                    data = data.replace("{website-start-date-time}",
                                        str(self.statistics.start_date_time))
                    data = data.replace("{website-total-number-of-requests}",
                                        str(total_number_of_requests))
                    data = data.replace("<p>{website-requests}</p>", requests)
                    self.client.write(data.to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_statistics(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version_statistics(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_mys(self, method: string, path: string):
        mys = self.database.get_mys()

        if mys is not None:
            path = f"/{mys.latest_release.version}{path}"
            self.handle_mys_version(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_package_operations(self,
                                  method: string,
                                  path: string,
                                  params: {string: string}):
        match method:
            case "DELETE":
                package_name = path[9:]
                package = self.database.get_package(package_name)

                if package is None:
                    self.write_response(Status.NotFound)
                    return

                if not self.validate_token(params, package.token):
                    return

                self.database.delete_package(package)
                package_database_path = self.database.make_path(
                    f"package/{package_name}")
                rm(package_database_path, recursive=True, force=True)

                for release in package.releases:
                    release_database_path = self.database.make_path(
                        f"package/{package.name}-{release.version}.tar.gz")
                    rm(release_database_path, force=True)

                self.write_response(Status.Ok)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_latest(self, method: string, path: string):
        parts = path.split('/')
        package_name = parts[2]
        package = self.database.get_package(package_name)

        if package is not None:
            path = path.replace("latest", package.latest_release.version)
            self.handle_mys_version(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_package(self, method: string, path: string):
        match method:
            case "GET":
                if ".." in path:
                    self.write_response(Status.BadRequest)
                    return

                path = self.database.make_path(path[1:])

                if exists(path):
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def generate_package_documentation(self,
                                       package_name: string,
                                       version: string):
        database_doc_path = self.database.make_path(
            f"package/{package_name}/{version}")
        rm(database_doc_path, recursive=True, force=True)
        mkdir(database_doc_path, exists_ok=True)

        if exists(f"{self.root_directory}/doc"):
            try:
                run(f"mys -C {self.root_directory} doc")
                run(f"mv {self.root_directory}/build/doc/html/* "
                    f"{database_doc_path}")
            except OsError:
                data = b"<html>Package documentation build failed!</html>"
                BinaryFile(f"{database_doc_path}/index.html", "w").write(data)
        else:
            data = b"<html>No package documentation found!</html>"
            BinaryFile(f"{database_doc_path}/index.html", "w").write(data)

    def handle_package_tar_gz(self,
                              method: string,
                              path: string,
                              params: {string: string},
                              headers: {string: string}):
        database_path = self.database.make_path(path[1:])

        match method:
            case "GET":
                self.handle_package_tar_gz_get(database_path)
            case "POST":
                self.handle_package_tar_gz_post(path, params, headers, database_path)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_latest_tar_gz(self, method: string, path: string):
        match method:
            case "GET":
                package_name = path[9:-14]
                package = self.database.get_package(package_name)

                if package is not None:
                    version = package.latest_release.version
                    path = f"package/{package_name}-{version}.tar.gz"
                    self.handle_package_tar_gz_get(self.database.make_path(path))
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_tar_gz_get(self, database_path: string):
        if exists(database_path):
            data = BinaryFile(database_path).read()
            self.write_response(Status.Ok)
            self.client.write(data)
        else:
            self.write_response(Status.NotFound)

    def save_post_data_to_file(self,
                               max_size: i64,
                               headers: {string: string}) -> string:
        content_length = u32(headers["Content-Length"])

        if content_length > 50_000_000:
            self.write_response(Status.BadRequest)

            return None

        expect = headers.get("Expect", "")

        if expect == "100-continue":
            self.write_response(Status.Continue)

        data = self.client.read(content_length)
        self.create_root_directory()
        fiber_path = self.make_path("archive.tar.gz")
        BinaryFile(fiber_path, "w").write(data)

        return fiber_path

    def validate_token(self,
                       params: {string: string},
                       expected_token: string) -> bool:
        token = params.get("token", None)

        if token is None:
            self.write_response(Status.BadRequest)

            return False

        if token != expected_token:
            self.write_response(Status.Unauthorized)

            return False

        return True

    def handle_package_tar_gz_post(self,
                                   path: string,
                                   params: {string: string},
                                   headers: {string: string},
                                   database_path: string):
        fiber_path = self.save_post_data_to_file(1_000_000, headers)

        if fiber_path is None:
            return

        tar(fiber_path,
            extract=True,
            strip_components=1,
            output_directory=self.root_directory)
        package_toml = TextFile(self.make_path("package.toml")).read()
        config = toml_decode(package_toml)
        package_name = config.get("package").get("name").get_string()
        version = config.get("package").get("version").get_string()

        try:
            description = config.get("package").get("description").get_string()
        except KeyError:
            description = "No description found."

        if package_name.match(re"^[\w\-]+$") is None:
            self.write_response(Status.BadRequest)
            return

        package = self.database.get_package(package_name)

        if package is None:
            self.database.create_package(package_name, create_token())
            package = self.database.get_package(package_name)
            response_data = f"{{\"token\": \"{package.token}\"}}"
        else:
            if not self.validate_token(params, package.token):
                return

            response_data = ""

        self.database.add_package_release(package, version, description)
        release = self.database.get_package_release(package, version)

        if package.latest_release is None:
            self.database.modify_package(package, release)
        elif is_later_version(version, package.latest_release.version):
            self.database.modify_package(package, release)

        run(f"mv {fiber_path} {database_path}")
        self.generate_package_documentation(package_name, version)
        self.write_response(Status.Ok, data=response_data)

    def handle_mys_tar_gz(self,
                          method: string,
                          path: string,
                          params: {string: string},
                          headers: {string: string}):
        database_path = self.database.make_path(path[1:])

        match method:
            case "POST":
                self.handle_mys_tar_gz_post(path, params, headers, database_path)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_mys_tar_gz_post(self,
                               path: string,
                               params: {string: string},
                               headers: {string: string},
                               database_path: string):
        fiber_path = self.save_post_data_to_file(50_000_000, headers)

        if fiber_path is None:
            return

        version = path[5:-7]
        rm(self.database.make_path(version), recursive=True, force=True)
        tar(fiber_path,
            extract=True,
            output_directory=self.database.root_directory)

        mys = self.database.get_mys()

        if mys is None:
            self.database.create_mys(create_token())
            mys = self.database.get_mys()
            response_data = f"{{\"token\": \"{mys.token}\"}}"
        else:
            if not self.validate_token(params, mys.token):
                return

            response_data = ""

        self.database.add_mys_release(version)
        release = self.database.get_mys_release(version)

        if mys.latest_release is None:
            self.database.modify_mys(release)
        elif is_later_version(version, mys.latest_release.version):
            self.database.modify_mys(release)

        self.write_response(Status.Ok, data=response_data)

    def handle_static_file(self, method: string, path: string):
        match method:
            case "GET":
                path = f"{__assets__}{path}"

                if exists(path) and ".." not in path:
                    self.write_static_response_ok(path)
                    self.client.write(BinaryFile(path).read())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def write_response(self,
                       status: Status,
                       headers: {string: string} = {},
                       data: string = None):
        status_string = _STATUS_STRINGS[i64(status)]
        print(status, status_string)
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n".to_utf8())

        for name, value in headers:
            self.client.write(f"{name}: {value}\r\n".to_utf8())

        if data is None:
            self.client.write("\r\n".to_utf8())
        else:
            data_bytes = data.to_utf8()
            self.client.write(f"Content-Length: {len(data_bytes)}\r\n\r\n".to_utf8())
            self.client.write(data_bytes)

    def write_static_response_ok(self, path: string):
        if path.ends_with(".html"):
            self.write_response(Status.Ok)
        else:
            self.write_response(Status.Ok,
                                headers={
                                    "Cache-Control": "public, max-age=7200"
                                })

class Statistics:
    start_date_time: LocalDateTime
    requests: {string: i64}

    def __init__(self):
        self.start_date_time = LocalDateTime()
        self.requests = {}

    def handle_request(self, method: string, path: string):
        key = f"{method} {path}"

        if key in self.requests:
            self.requests[key] += 1
        else:
            self.requests[key] = 1

def main(argv: [string]):
    parser = Parser("website")
    parser.add_option("--port",
                      short="-p",
                      default="8000",
                      help="Port to listen for clients on (default: 8000).")
    parser.add_option("--database-directory",
                      short="-d",
                      default=".",
                      help="Database directory (default: \".\").")
    args = parser.parse(argv)

    database = Database(args.value_of("--database-directory"))
    statistics = Statistics()

    client_handlers: [ClientHandlerFiber] = []

    for i in range(20):
        client_handlers += ClientHandlerFiber(database,
                                              statistics,
                                              client_handlers,
                                              i)
        client_handlers[-1].start()

    server = Server()
    port = u32(args.value_of("--port"))
    server.listen(port)

    print(f"Listening for clients on port {port}.")

    while True:
        client = server.accept()

        if len(client_handlers) > 0:
            client_handler = client_handlers.pop()
            client_handler.client = client
            client_handler.event.set()
        else:
            print("No client handler available.")
