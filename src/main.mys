from argparse import Parser
from net.tcp.server import Server
from net.tcp.server import Client
from os import BinaryFile
from .database import Database
from .database import Package
from .database import Release

class ClientError(Error):
    pass

@enum
class Status:
    NotFound = 404
    MethodNotAllowed = 405

_STATUS_STRINGS: {i64: string} = {
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

_HOST: string = None

class HttpClient:
    client: Client
    database: Database

    def read_line(self) -> string:
        line = b""

        while True:
            byte = self.client.read(1)

            if len(byte) != 1:
                raise ClientError()

            line += byte

            if len(line) < 2:
                continue

            if line[-2] == u8('\r') and line[-1] == u8('\n'):
                break

        return string(line)[:-2]

    def read_request_line(self) -> (string, string):
        line = self.read_line()
        mo = line.match(re"^(\w+) (.+) HTTP/1.1$")

        if mo is None:
            return None

        return (mo.group(1), mo.group(2))

    def read_headers(self) -> {string: string}:
        headers: {string: string} = {}

        while True:
            line = self.read_line()

            if len(line) == 0:
                break

            mo = line.match(re"^([^:]+): (.*)$")

            if mo is not None:
                headers[mo.group(1)] = mo.group(2)

        return headers

    def run(self):
        method, path = self.read_request_line()
        headers = self.read_headers()

        print(method, path)

        if path == "/":
            self.handle_index(method)
        elif path.match(re"^/package/[^/]+.tar.gz$") is not None:
            self.handle_package_archive(method, path, headers)
        elif path.starts_with("/package/"):
            self.handle_package(method, path)
        else:
            self.send_error(Status.NotFound)

    def handle_index(self, method: string):
        match method:
            case "GET":
                self.client.write("HTTP/1.1 200 OK\r\n"
                                  "\r\n".to_utf8())
                self.client.write(BinaryFile("src/static/index.html").read())
            case _:
                self.send_error(Status.MethodNotAllowed)

    def handle_package(self, method: string, path: string):
        package_name = path.strip_left("/package/")

        match method:
            case "GET":
                package = self.database.get_package(package_name)

                if package is not None:
                    self.client.write("HTTP/1.1 200 OK\r\n"
                                      "\r\n".to_utf8())
                    releases = ""

                    for release in package.releases:
                        href = (f"http://{_HOST}/package/"
                                f"{package.name}-{release.version}.tar.gz")
                        releases += ("    <li>"
                                     f"<a href=\"{href}\">{release.version}</a>"
                                     "</li>\n")

                    self.client.write(
                        "<html>\n"
                        f"  <title>{package.name}</title>\n"
                        f"  <h1>{package.name}</h1>\n"
                        "  <h3>Releases</h3>\n"
                        "  <ul>\n"
                        f"{releases}"
                        "  </ul>\n"
                        "</html>".to_utf8())
                else:
                    self.send_error(Status.NotFound)
            case _:
                self.send_error(Status.MethodNotAllowed)

    def handle_package_archive(self,
                               method: string,
                               path: string,
                               headers: {string: string}):
        path = path.strip_left("/")

        match method:
            case "GET":
                data = BinaryFile(path).read()
                self.client.write("HTTP/1.1 200 OK\r\n"
                                  "\r\n".to_utf8())
                self.client.write(data)
            case "POST":
                data = self.client.read(u32(headers["Content-Length"]))
                # BinaryFile(path, "w").write(data)
                self.client.write("HTTP/1.1 200 OK\r\n"
                                  "\r\n".to_utf8())
            case _:
                self.send_error(Status.MethodNotAllowed)

    def send_error(self, status: Status):
        status_string = _STATUS_STRINGS[i64(status)]
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n"
                          "\r\n".to_utf8())

def main(argv: [string]):
    parser = Parser("website")
    parser.add_option("--host",
                      short="-h",
                      default="localhost:8000",
                      help="Host in website links (default: localhost:8000).")
    parser.add_option("--port",
                      short="-p",
                      default="8000",
                      help="Port to listen for clients on (default: 8000).")
    parser.add_option("--storage-directory",
                      short="-d",
                      default=".",
                      help="Storage directory (default: \".\").")
    args = parser.parse(argv)

    _HOST = args.value_of("--host")

    database = Database()

    server = Server()
    port = u32(args.value_of("--port"))
    server.listen(port)

    print(f"Listening for clients on port {port}.")

    while True:
        client = server.accept()

        try:
            HttpClient(client, database).run()
        except:
            pass

        client.disconnect()
