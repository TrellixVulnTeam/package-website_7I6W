from argparse import Parser
from net.tcp.server import Server
from net.tcp.server import Client
from os import BinaryFile
from os import TextFile
from os import tar
from os import exists
from os import mkdir
from os import system
from .database import Database
from .database import Package
from .database import Release
from toml import decode as toml_decode
from toml import Value as TomlValue
from fiber import Fiber
from fiber import Event

class ReadError(Error):
    pass

@enum
class Status:
    Continue = 100
    Ok = 200
    BadRequest = 400
    NotFound = 404
    MethodNotAllowed = 405

_STATUS_STRINGS: {i64: string} = {
    i64(Status.Continue): "Continue",
    i64(Status.Ok): "OK",
    i64(Status.BadRequest): "Bad Request",
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

class HttpClient:
    client: Client
    database: Database
    root_directory: string

    def make_path(self, path: string) -> string:
        """Prepend the database root directory path to given path. Given path
        must not start with a slash.

        """

        return f"{self.root_directory}/{path}"

    def read_line(self) -> string:
        line = b""

        while True:
            byte = self.client.read(1)

            if len(byte) != 1:
                raise ReadError()

            line += byte

            if len(line) < 2:
                continue

            if line[-2] == u8('\r') and line[-1] == u8('\n'):
                break

        return string(line)[:-2]

    def read_request_line(self) -> (string, string, string):
        line = self.read_line()
        mo = line.match(re"^(\w+) ([^? ]+)\??(.*) HTTP/1.1$")

        if mo is None:
            print("Bad request line:", line)

            return None

        return (mo.group(1), mo.group(2), mo.group(3))

    def read_headers(self) -> {string: string}:
        headers: {string: string} = {}

        while True:
            line = self.read_line()

            if len(line) == 0:
                break

            mo = line.match(re"^([^:]+): (.*)$")

            if mo is not None:
                headers[mo.group(1)] = mo.group(2)

        return headers

    def run(self):
        request = self.read_request_line()

        if request is None:
            self.write_response(Status.BadRequest)

            return

        method, path, params = request
        headers = self.read_headers()

        print(method, path, params)

        if path == "/":
            self.handle_index(method)
        elif path == "/favicon.ico":
            self.handle_favicon(method)
        elif path.match(re"^/package/[\w-]+-\d+\.\d+\.\d+[\w-]*.tar.gz$") is not None:
            self.handle_package_tar_gz(method, path, headers)
        elif path.starts_with("/package/"):
            self.handle_package(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_index(self, method: string):
        match method:
            case "GET":
                packages = ""

                for package_name in self.database.get_packages():
                    packages += (
                        "      <li>"
                        f"<a href=\"/package/{package_name}\">{package_name}</a>"
                        "</li>\n")

                self.write_response(Status.Ok)
                self.client.write(
                    "<html>\n"
                    "  <title>The Mys Programming Language</title>\n"
                    "  <body>\n"
                    "    <h1>Welcome!</h1>\n"
                    "    <a href=\"https://github.com/mys-lang/mys\">"
                    "GitHub</a>: Mys' official project repository.\n"
                    "    </br>\n"
                    "    </br>\n"
                    "    <a href=\"https://mys.readthedocs.org/en/latest/\">"
                    "The Mys documentation</a>: Mys' official documentation. The best "
                    "place to start learning Mys.\n"
                    "    <h3>Packages</h3>\n"
                    "    <ul>\n"
                    f"{packages}"
                    "    </ul>\n"
                    "  </body>\n"
                    "</html>".to_utf8())
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_favicon(self, method: string):
        match method:
            case "GET":
                self.write_response(Status.Ok)
                self.client.write(BinaryFile(f"{__assets__}/favicon.ico").read())
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package(self, method: string, path: string):
        package_name = path[9:]

        match method:
            case "GET":
                package = self.database.get_package(package_name)

                if package is not None:
                    releases = ""

                    for release in package.releases:
                        href = f"/package/{package.name}-{release.version}.tar.gz"
                        releases += (
                            "    <li>"
                            f"<a href=\"{href}\" download>{release.version}</a>"
                            "</li>\n")

                    homepage_url = (
                        f"https://github.com/mys-lang/package-{package.name}")
                    doc_url = (
                        f"https://mys-package-{package.name}.readthedocs.io/en/latest")

                    self.write_response(Status.Ok)
                    self.client.write(
                        "<html>\n"
                        f"  <title>{package.name}</title>\n"
                        f"  <h1>{package.name}</h1>\n"
                        f"  Homepage: <a href=\"{homepage_url}\">{homepage_url}</a>\n"
                        "  <br/>"
                        "  <br/>"
                        f"  Documentation: <a href=\"{doc_url}\">{doc_url}</a>\n"
                        "  <h3>Releases</h3>\n"
                        "  <ul>\n"
                        f"{releases}"
                        "  </ul>\n"
                        "</html>".to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_tar_gz(self,
                              method: string,
                              path: string,
                              headers: {string: string}):
        name_and_version = path[9:-7]
        database_path = self.database.make_path(path[1:])

        match method:
            case "GET":
                if exists(database_path):
                    data = BinaryFile(database_path).read()
                    self.write_response(Status.Ok)
                    self.client.write(data)
                else:
                    self.write_response(Status.NotFound)
            case "POST":
                content_length = u32(headers["Content-Length"])

                if content_length > 1_000_000:
                    self.write_response(Status.BadRequest)
                    return

                expect = headers.get("Expect", "")

                if expect == "100-continue":
                    self.write_response(Status.Continue)

                data = self.client.read(content_length)
                fiber_path = self.make_path("archive.tar.gz")
                BinaryFile(fiber_path, "w").write(data)
                tar(fiber_path,
                    extract=True,
                    path=f"{name_and_version}/package.toml",
                    strip_components=1,
                    output_directory=self.root_directory)
                system(f"mv {fiber_path} {database_path}")
                package_toml = TextFile(self.make_path("package.toml")).read()
                config = toml_decode(package_toml)
                package_name = config.get("package").get("name").get_string()
                package_version = config.get("package").get("version").get_string()
                package = self.database.get_package(package_name)

                if package is None:
                    self.database.create_package(package_name)
                    package = self.database.get_package(package_name)

                self.database.add_package_release(package.package_id, package_version)
                self.write_response(Status.Ok)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def write_response(self, status: Status):
        status_string = _STATUS_STRINGS[i64(status)]
        print(status, status_string)
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n"
                          "\r\n".to_utf8())

class ClientHandlerFiber(Fiber):
    database: Database
    event: Event
    client: Client
    client_handlers: [ClientHandlerFiber]
    root_directory: string

    def __init__(self,
                 database: Database,
                 client_handlers: [ClientHandlerFiber],
                 index: i64):
        self.database = database
        self.client_handlers = client_handlers
        self.root_directory = f".website/{index}"
        self.event = Event()
        self.client = None
        mkdir(self.root_directory, exists_ok=True)

    def run(self):
        while True:
            self.event.wait()
            self.event.clear()

            try:
                HttpClient(self.client, self.database, self.root_directory).run()
            except Error as e:
                print(e)

            self.client.disconnect()
            self.client_handlers += self

def main(argv: [string]):
    parser = Parser("website")
    parser.add_option("--port",
                      short="-p",
                      default="8000",
                      help="Port to listen for clients on (default: 8000).")
    parser.add_option("--database-directory",
                      short="-d",
                      default=".",
                      help="Database directory (default: \".\").")
    args = parser.parse(argv)

    database = Database(args.value_of("--database-directory"))

    client_handlers: [ClientHandlerFiber] = []

    for i in range(20):
        client_handlers += ClientHandlerFiber(database, client_handlers, i)
        client_handlers[-1].start()

    server = Server()
    port = u32(args.value_of("--port"))
    server.listen(port)

    print(f"Listening for clients on port {port}.")

    while True:
        client = server.accept()

        if len(client_handlers) > 0:
            client_handler = client_handlers.pop()
            client_handler.client = client
            client_handler.event.set()
        else:
            print("No client handler available.")
