from argparse import Parser
from net.tcp.server import Server
from net.tcp.server import Client
from os import mkdir
from os import BinaryFile
from os import TextFile
from os import tar
from os import exists
from .database import Database
from .database import Package
from .database import Release

class ReadError(Error):
    pass

@enum
class Status:
    Continue = 100
    Ok = 200
    BadRequest = 400
    NotFound = 404
    MethodNotAllowed = 405

_STATUS_STRINGS: {i64: string} = {
    i64(Status.Continue): "Continue",
    i64(Status.Ok): "OK",
    i64(Status.BadRequest): "Bad Request",
    i64(Status.NotFound): "Not Found",
    i64(Status.MethodNotAllowed): "Method Not Allowed"
}

class HttpClient:
    client: Client
    database: Database

    def read_line(self) -> string:
        line = b""

        while True:
            byte = self.client.read(1)

            if len(byte) != 1:
                raise ReadError()

            line += byte

            if len(line) < 2:
                continue

            if line[-2] == u8('\r') and line[-1] == u8('\n'):
                break

        return string(line)[:-2]

    def read_request_line(self) -> (string, string, string):
        line = self.read_line()
        mo = line.match(re"^(\w+) ([^? ]+)\??(.*) HTTP/1.1$")

        if mo is None:
            return None

        return (mo.group(1), mo.group(2), mo.group(3))

    def read_headers(self) -> {string: string}:
        headers: {string: string} = {}

        while True:
            line = self.read_line()

            if len(line) == 0:
                break

            mo = line.match(re"^([^:]+): (.*)$")

            if mo is not None:
                headers[mo.group(1)] = mo.group(2)

        return headers

    def run(self):
        method, path, params = self.read_request_line()
        headers = self.read_headers()

        print(method, path, params)

        if path == "/":
            self.handle_index(method)
        elif path == "/favicon.ico":
            self.handle_favicon(method)
        elif path.match(re"^/package/[^/]+.tar.gz$") is not None:
            self.handle_package_tar_gz(method, path, headers)
        elif path.starts_with("/package/"):
            self.handle_package(method, path)
        else:
            self.write_response(Status.NotFound)

    def handle_index(self, method: string):
        match method:
            case "GET":
                packages = ""

                for package_name in self.database.get_packages():
                    packages += (
                        "      <li>"
                        f"<a href=\"/package/{package_name}\">{package_name}</a>"
                        "</li>\n")

                self.write_response(Status.Ok)
                self.client.write(
                    "<html>\n"
                    "  <title>The Mys Programming Language</title>\n"
                    "  <body>\n"
                    "    <h1>Welcome!</h1>\n"
                    "    <a href=\"https://github.com/mys-lang/mys\">"
                    "GitHub</a>: Mys' official project repository.\n"
                    "    </br>\n"
                    "    </br>\n"
                    "    <a href=\"https://mys.readthedocs.org/en/latest/\">"
                    "The Mys documentation</a>: Mys' official documentation. The best "
                    "place to start learning Mys.\n"
                    "    <h3>Packages</h3>\n"
                    "    <ul>\n"
                    f"{packages}"
                    "    </ul>\n"
                    "  </body>\n"
                    "</html>".to_utf8())
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_favicon(self, method: string):
        match method:
            case "GET":
                self.write_response(Status.Ok)
                self.client.write(BinaryFile("favicon.ico").read())
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package(self, method: string, path: string):
        package_name = path.strip_left("/package/")

        match method:
            case "GET":
                package = self.database.get_package(package_name)

                if package is not None:
                    releases = ""

                    for release in package.releases:
                        href = f"/package/{package.name}-{release.version}.tar.gz"
                        releases += (
                            "    <li>"
                            f"<a href=\"{href}\" download>{release.version}</a>"
                            "</li>\n")

                    self.write_response(Status.Ok)
                    self.client.write(
                        "<html>\n"
                        f"  <title>{package.name}</title>\n"
                        f"  <h1>{package.name}</h1>\n"
                        "  <h3>Releases</h3>\n"
                        "  <ul>\n"
                        f"{releases}"
                        "  </ul>\n"
                        "</html>".to_utf8())
                else:
                    self.write_response(Status.NotFound)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def handle_package_tar_gz(self,
                              method: string,
                              path: string,
                              headers: {string: string}):
        path = path.strip_left("/")

        match method:
            case "GET":
                if exists(path):
                    data = BinaryFile(path).read()
                    self.write_response(Status.Ok)
                    self.client.write(data)
                else:
                    self.write_response(Status.NotFound)
            case "POST":
                expect = headers.get("Expect", "")

                if expect == "100-continue":
                    self.write_response(Status.Continue)

                data = self.client.read(u32(headers["Content-Length"]))
                BinaryFile(path, "w").write(data)
                tar(path, extract=True)
                print(TextFile(path[8:-7] + "/package.toml").read())
                self.write_response(Status.Ok)
            case _:
                self.write_response(Status.MethodNotAllowed)

    def write_response(self, status: Status):
        status_string = _STATUS_STRINGS[i64(status)]
        self.client.write(f"HTTP/1.1 {status} {status_string}\r\n"
                          "\r\n".to_utf8())

def main(argv: [string]):
    parser = Parser("website")
    parser.add_option("--port",
                      short="-p",
                      default="8000",
                      help="Port to listen for clients on (default: 8000).")
    parser.add_option("--storage-directory",
                      short="-d",
                      default=".",
                      help="Storage directory (default: \".\").")
    args = parser.parse(argv)

    database = Database()
    mkdir("package", exists_ok=True)

    server = Server()
    port = u32(args.value_of("--port"))
    server.listen(port)

    print(f"Listening for clients on port {port}.")

    while True:
        client = server.accept()

        try:
            HttpClient(client, database).run()
        except Error as e:
            print(e)

        client.disconnect()
