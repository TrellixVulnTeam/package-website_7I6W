from fiber import Fiber
from fiber import Queue
from http import get as http_get
from json import decode as json_decode
from json import Value as JsonValue
from time import LocalDateTime

def _get_item(location: {string: JsonValue}, key: string) -> string:
    value = location.get(key, None)

    if value is not None:
        return value.get_string()
    else:
        return ""

def _to_f64(value: string) -> f64:
    if value[0] == '-':
        return -1.0 * f64(value[1:])
    else:
        return f64(value)

class Location:
    latitude: f64
    longitude: f64

    def __init__(self, latitude: f64, longitude: f64):
        self.latitude = latitude
        self.longitude = longitude

class _ClientIpLookupFiber(Fiber):
    token: string
    queue: Queue[string]
    locations: {string: Location}
    _locations_order: [string]

    def __init__(self, token: string, locations: {string: Location}):
        self.token = token
        self.queue = Queue[string]()
        self.locations = locations
        self._locations_order = []

    def run(self):
        while True:
            client_ip_address = self.queue.get()

            if self.token is None:
                continue

            if client_ip_address in self.locations:
                continue

            try:
                content = string(http_get("ipinfo.io",
                                          80,
                                          f"/{client_ip_address}?token={self.token}",
                                          secure=False)[1])
                location = json_decode(content).get_object()
                parts = _get_item(location, "loc").split(',')
                latitude = _to_f64(parts[0])
                longitude = _to_f64(parts[1])

                if len(self._locations_order) == 25:
                    self.locations.pop(self._locations_order.pop(0), None)

                self.locations[client_ip_address] = Location(latitude, longitude)
                self._locations_order += client_ip_address
            except Error as e:
                print(e)

class Statistics:
    start_date_time: LocalDateTime
    requests: {string: i64}
    locations: {string: Location}
    clients_ip_addresses: {string}
    client_ip_lookup_fiber: _ClientIpLookupFiber

    def __init__(self, ipinfo_token: string):
        self.start_date_time = LocalDateTime()
        self.requests = {}
        self.locations = {}
        self.clients_ip_addresses = {}
        self.client_ip_lookup_fiber = _ClientIpLookupFiber(ipinfo_token,
                                                           self.locations)
        self.client_ip_lookup_fiber.start()

    def handle_request(self,
                       method: string,
                       path: string,
                       client_ip_address: string):
        key = f"{method} {path}"

        if key in self.requests:
            self.requests[key] += 1
        elif len(self.requests) < 1000:
            self.requests[key] = 1

        if client_ip_address is not None:
            if len(self.clients_ip_addresses) < 1000:
                self.clients_ip_addresses.add(client_ip_address)

            self.client_ip_lookup_fiber.queue.put(client_ip_address)
