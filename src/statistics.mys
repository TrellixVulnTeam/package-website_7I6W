from fiber import Fiber
from fiber import Queue
from http import get as http_get
from json import decode as json_decode
from json import Value as JsonValue
from time import LocalDateTime
from collections.fifo import Fifo
from .main import Status

RE_LOCATION: regex = re"^([\d.-]+),([\d.-]+)$"

class Location:
    latitude: f64
    longitude: f64
    response_status: Status

class _ClientIpLookupFiber(Fiber):
    token: string
    queue: Queue[(string, i64)]
    locations: {string: Location}
    _locations_order: Fifo[string]

    def __init__(self, token: string, locations: {string: Location}):
        self.token = token
        # i64 instead of Status as generics does only work with common
        # types.
        self.queue = Queue[(string, i64)]()
        self.locations = locations
        self._locations_order = Fifo[string](100)

    def run(self):
        while True:
            client_ip_address, response_status = self.queue.get()

            if self.token is None:
                continue

            location = self.locations.get(client_ip_address, None)

            if location is not None:
                location.response_status = Status(response_status)
                continue

            try:
                content = string(http_get("ipinfo.io",
                                          80,
                                          f"/{client_ip_address}?token={self.token}",
                                          secure=False)[1])

                mo = json_decode(content).get("loc").get_string().match(RE_LOCATION)

                if mo is None:
                    continue

                latitude = f64(mo.group(1))
                longitude = f64(mo.group(2))

                if self._locations_order.is_full():
                    self.locations.pop(self._locations_order.pop(), None)

                self.locations[client_ip_address] = Location(latitude,
                                                             longitude,
                                                             Status(response_status))
                self._locations_order.push(client_ip_address)
            except Error as e:
                print(e)

class Statistics:
    start_date_time: LocalDateTime
    requests: {string: i64}
    locations: {string: Location}
    clients_ip_addresses: {string}
    client_ip_lookup_fiber: _ClientIpLookupFiber
    referrers: {string: i64}

    def __init__(self, ipinfo_token: string):
        self.start_date_time = LocalDateTime()
        self.requests = {}
        self.locations = {}
        self.clients_ip_addresses = {}
        self.referrers = {}
        self.client_ip_lookup_fiber = _ClientIpLookupFiber(ipinfo_token,
                                                           self.locations)
        self.client_ip_lookup_fiber.start()

    def handle_request(self,
                       method: string,
                       path: string,
                       response_status: Status,
                       client_ip_address: string,
                       referrer: string):
        if not path.ends_with(".html"):
            return

        key = f"{method} {path}"

        if key in self.requests:
            self.requests[key] += 1
        elif len(self.requests) < 1000:
            self.requests[key] = 1

        if referrer is not None:
            if referrer in self.referrers:
                self.referrers[referrer] += 1
            elif len(self.referrers) < 1000:
                self.referrers[referrer] = 1

        if client_ip_address is not None:
            if len(self.clients_ip_addresses) < 1000:
                self.clients_ip_addresses.add(client_ip_address)

            self.client_ip_lookup_fiber.queue.put((client_ip_address,
                                                   i64(response_status)))
